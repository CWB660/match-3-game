<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ‘ ç¾Šäº†ä¸ªç¾Š</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            color: #2c3e50;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }
        
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: min(2vw, 24px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            margin: 0;
            padding: 10px;
            width: 100%;
            height: 100%;
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }
        
        .game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7);
            border-radius: 24px 24px 0 0;
        }
        
        canvas {
            border: none;
            background: linear-gradient(145deg, #ffffff, #f8fafc);
            cursor: pointer;
            border-radius: min(2vw, 16px);
            box-shadow: 
                0 10px 25px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transition: all 0.3s ease;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
        }
        
        canvas:hover {
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }
        
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 0;
            padding: min(1vh, 10px) 0;
            height: 100%;
        }
        
        .game-title {
            text-align: center;
            margin: 0 0 min(1vh, 10px) 0;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .game-subtitle {
            text-align: center;
            margin: 0 0 min(1.5vh, 15px) 0;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            color: #64748b;
            font-weight: 500;
        }
        
        .info {
            font-size: 0.8rem;
            color: #475569;
            font-weight: 500;
        }
        
        .slot-container {
            text-align: center;
            background: linear-gradient(145deg, #f8fafc, #e2e8f0);
            border-radius: min(1.5vw, 15px);
            padding: min(1vh, 12px) min(1.5vw, 15px);
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            flex-shrink: 0;
        }
        
        .slot-title {
            font-size: 1rem;
            font-weight: 600;
            color: #334155;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .slot-title::before,
        .slot-title::after {
            content: '';
            width: 40px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #94a3b8, transparent);
        }
        
        .slots {
            display: flex;
            justify-content: center;
            gap: min(1vw, 8px);
            margin: min(1vh, 10px) 0;
            min-height: clamp(45px, 8vh, 60px);
            background: rgba(255, 255, 255, 0.6);
            border-radius: min(1.5vw, 12px);
            padding: min(1vh, 10px);
            border: 2px dashed #cbd5e1;
            transition: all 0.3s ease;
            flex-wrap: wrap;
        }
        
        .slots:has(.slot-card) {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.05);
        }
        
        .slot-card {
            width: 40px;
            height: 40px;
            border: 2px solid #10b981;
            border-radius: min(1vw, 8px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(16px, 4vw, 24px);
            background: linear-gradient(145deg, #10b981, #059669);
            color: white;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 
                0 3px 12px rgba(16, 185, 129, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        .slot-card:empty {
            background: transparent;
            border: 2px dashed #cbd5e1;
            box-shadow: none;
        }
        
        .slot-card.removing {
            animation: slotRemove 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes slotRemove {
            0% { 
                transform: scale(1) rotate(0deg); 
                opacity: 1; 
            }
            30% { 
                transform: scale(1.15) rotate(5deg); 
                background: linear-gradient(145deg, #f59e0b, #d97706);
                box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
            }
            100% { 
                transform: scale(0) rotate(180deg); 
                opacity: 0; 
            }
        }
        
        .slot-card.adding {
            animation: slotAdd 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        @keyframes slotAdd {
            0% { 
                transform: scale(0) translateY(-80px) rotate(-180deg); 
                opacity: 0; 
            }
            50% { 
                transform: scale(1.2) translateY(-20px) rotate(-90deg); 
            }
            100% { 
                transform: scale(1) translateY(0) rotate(0deg); 
                opacity: 1; 
            }
        }
        
        .slot-card.warning {
            border-color: #f59e0b;
            background: linear-gradient(145deg, #f59e0b, #d97706);
            animation: pulse 1.5s ease-in-out infinite;
            box-shadow: 
                0 4px 15px rgba(245, 158, 11, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        @keyframes pulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 8px 25px rgba(245, 158, 11, 0.6);
            }
        }
        
        .controls {
            margin: min(2vh, 20px) 0;
            display: flex;
            gap: min(2vw, 15px);
            justify-content: center;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        
        .btn {
            padding: clamp(10px, 2vh, 14px) clamp(20px, 4vw, 28px);
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            border: none;
            border-radius: min(1.5vw, 12px);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            font-family: inherit;
            position: relative;
            overflow: hidden;
            min-width: clamp(100px, 20vw, 120px);
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }
        
        .btn-danger:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }
        
        .btn-success:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
        }
        
        .btn-purple {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
        }
        
        .btn-purple:hover {
            background: linear-gradient(135deg, #7c3aed, #6d28d9);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4);
        }
        
        .level-info {
            margin: 0;
            display: flex;
            gap: min(1vw, 10px);
            justify-content: flex-start;
            font-size: clamp(0.7rem, 2vw, 0.85rem);
            font-weight: 600;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        
        .level-info .info {
            background: linear-gradient(135deg, #e0f2fe, #b3e5fc);
            padding: clamp(4px, 1vh, 8px) clamp(8px, 2vw, 12px);
            border-radius: min(2vw, 15px);
            border: 1px solid #0ea5e9;
            color: #0c4a6e;
            box-shadow: 0 2px 8px rgba(14, 165, 233, 0.2);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .level-info .info:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(14, 165, 233, 0.3);
        }
        
        @keyframes dangerPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            50% { box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.1); }
        }
        
        .top-bar {
            width: 100%;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            padding: 0 20px;
        }
        
        .top-bar .btn {
            font-size: 0.8rem;
            padding: 8px 16px;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.4s ease-out;
        }
        
        @keyframes fadeIn {
            from { 
                opacity: 0;
                backdrop-filter: blur(0px);
            }
            to { 
                opacity: 1;
                backdrop-filter: blur(5px);
            }
        }
        
        .modal-content {
            background: linear-gradient(145deg, #ffffff, #f8fafc);
            padding: 40px 50px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.05);
            animation: modalSlideIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            min-width: 400px;
            max-width: 90vw;
            position: relative;
            overflow: hidden;
        }
        
        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1);
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(-50px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        
        .modal-content h2 {
            margin-top: 0;
            color: #1e293b;
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 15px;
        }
        
        .modal-content p {
            font-size: 1.1rem;
            color: #64748b;
            margin: 20px 0 30px;
            line-height: 1.6;
        }
        
        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .game-status {
            text-align: center;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            font-weight: 500;
            padding: clamp(10px, 2vh, 15px) clamp(20px, 4vw, 25px);
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            border-radius: min(1.5vw, 12px);
            border: 1px solid #0ea5e9;
            color: #0c4a6e;
            margin: min(2vh, 20px) 0;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        
        /* å“åº”å¼è®¾è®¡ä¼˜åŒ– */
        @media (max-width: 768px) {
            .slots {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .modal-content {
                min-width: 85vw;
                max-width: 400px;
                padding: clamp(20px, 4vw, 30px);
            }
            
            .modal-content h2 {
                font-size: clamp(1.25rem, 5vw, 1.75rem);
            }
            
            .modal-buttons {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
        }
        
        @media (max-width: 480px) {
            
        }
        
        @media (orientation: landscape) and (max-height: 600px) {
            .game-container {
                overflow-y: auto;
            }
            
            .slot-container {
                margin: 0.5vh 0;
            }
            
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="top-bar">
            <div class="level-info">
                <div class="info">ç¬¬ <span id="currentLevel">1</span> å…³</div>
                <div class="info">éš¾åº¦ï¼š<span id="difficulty">ç®€å•</span></div>
            </div>
            <div style="display: flex; gap: 10px;">
                <!-- <button id="debugBtn" class="btn btn-purple" onclick="window.game.debugGameState()">è°ƒè¯•æ£€æŸ¥</button> -->
            <button id="restartBtn" class="btn btn-danger" onclick="window.game.restart()">é‡æ–°å¼€å§‹</button>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="gameCanvas"></canvas>
        </div>
        
        <!-- 8æ§½ä½åˆ—è¡¨ -->
        <div class="slot-container">
            <div class="slots" id="slotContainer">
                <!-- æ§½ä½å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

    </div>

    <div id="modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="modalTitle"></h2>
            <p id="modalMessage"></p>
            <div class="modal-buttons">
                <button id="modalNextLevelBtn" class="btn btn-primary" style="display: none;">ä¸‹ä¸€å…³</button>
                <button id="modalRestartBtn" class="btn btn-danger">é‡æ–°å¼€å§‹</button>
            </div>
        </div>
    </div>

    <script>
        class Card {
            constructor(x, y, layer, emoji, canvasSize) {
                this.x = x;
                this.y = y;
                this.layer = layer;
                this.emoji = emoji;
                this.visible = true;
                this.selected = false;
                this.isClickable = true;
                this.isBlocked = false;
                
                // æ ¹æ®canvaså°ºå¯¸åŠ¨æ€è®¡ç®—å¡ç‰Œå¤§å°
                const baseSize = Math.min(canvasSize.width / 18, canvasSize.height / 12, 65);
                this.width = Math.max(30, baseSize);
                this.height = Math.max(30, baseSize);
            }

            draw(ctx) {
                if (!this.visible) return;

                ctx.save();
                
                // å¡ç‰Œé˜´å½±
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                // å¡ç‰ŒèƒŒæ™¯ï¼šç»Ÿä¸€æµ…é»„è‰²ï¼Œåªæœ‰è¢«é®æŒ¡çš„æ‰å˜æš—
                if (this.selected) {
                    ctx.fillStyle = '#E8F5E8'; // é€‰ä¸­çŠ¶æ€ï¼šæ·¡ç»¿è‰²
                } else if (this.isBlocked) {
                    ctx.fillStyle = '#A5D6A7'; // è¢«é®æŒ¡çŠ¶æ€ï¼šæ·¡ç»¿è‰²
                } else {
                    ctx.fillStyle = '#F8FFD1'; // æ­£å¸¸çŠ¶æ€ï¼šæµ…é»„è‰²
                }
                
                // ç»˜åˆ¶åœ†è§’çŸ©å½¢
                const cardRadius = 8;
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, cardRadius);
                ctx.fill();
                
                // å¡ç‰Œè¾¹æ¡†ï¼šç»Ÿä¸€æš—ç»¿è‰²è¾¹æ¡†
                if (this.selected) {
                    ctx.strokeStyle = '#1B5E20'; // é€‰ä¸­çŠ¶æ€ï¼šå¾ˆæš—çš„æ·±ç»¿è‰²è¾¹æ¡†
                    ctx.lineWidth = 3;
                    ctx.shadowColor = 'rgba(27, 94, 32, 0.5)';
                    ctx.shadowBlur = 6;
                } else if (this.isBlocked) {
                    ctx.strokeStyle = '#2E7D32'; // è¢«é®æŒ¡çŠ¶æ€ï¼šæš—ç»¿è‰²è¾¹æ¡†
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(46, 125, 50, 0.2)';
                    ctx.shadowBlur = 2;
                } else {
                    // æ­£å¸¸çŠ¶æ€ï¼šæ·±ç»¿è‰²è¾¹æ¡†
                    ctx.strokeStyle = '#1B5E20';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(27, 94, 32, 0.3)';
                    ctx.shadowBlur = 3;
                }
                
                // ç»˜åˆ¶åœ†è§’è¾¹æ¡†
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, cardRadius);
                ctx.stroke();
                
                // é‡ç½®é˜´å½±æ•ˆæœï¼Œé¿å…å½±å“åç»­ç»˜åˆ¶
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                // ç»˜åˆ¶emojiï¼šåªæœ‰è¢«é®æŒ¡çš„æ‰å˜æš—
                const fontSize = Math.min(this.width * 0.5, this.height * 0.5, 32);
                ctx.font = `${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                if (this.isBlocked) {
                    ctx.fillStyle = '#424242'; // è¢«é®æŒ¡çŠ¶æ€ï¼šå¾ˆæš—çš„ç°è‰²
                } else {
                    ctx.fillStyle = '#FFFFFF'; // æ­£å¸¸çŠ¶æ€ï¼šçº¯ç™½è‰²
                }
                ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height/2);

                // å±‚çº§æ ‡è¯†ï¼ˆè°ƒè¯•ç”¨ï¼‰
                ctx.font = '10px Arial';
                ctx.fillStyle = '#666';
                ctx.fillText(this.layer.toString(), this.x + 5, this.y + 10);

                // ä¸ºè¢«é®æŒ¡çš„å¡ç‰Œæ·»åŠ åŠé€æ˜è¦†ç›–å±‚ï¼Œå¢å¼ºæš—æ·¡æ•ˆæœ
                if (this.isBlocked) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.beginPath();
                    ctx.roundRect(this.x, this.y, this.width, this.height, cardRadius);
                    ctx.fill();
                }

                ctx.restore();
            }

  
            isPointInside(x, y) {
                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }
        }

        class Game {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.cards = [];
                this.slots = []; // æ§½ä½ä¸­çš„å¡ç‰Œ
                this.maxSlots = 8; // æœ€å¤š8ä¸ªæ§½ä½
                this.currentLevel = 1;
                this.maxLevel = 10;
                this.emojis = ['ğŸ‘', 'ğŸŒŸ', 'ğŸˆ', 'ğŸŒº', 'ğŸ', 'ğŸš€', 'ğŸŒˆ', 'ğŸ¯', 'ğŸ¦‹', 'ğŸŒ¸', 'ğŸŠ', 'ğŸ¦„', 'ğŸ±', 'ğŸ¶', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ¸'];
                this.isRemoving = false; // é˜²æ­¢é‡å¤ç§»é™¤çš„æ ‡å¿—
                
                // å…³å¡é…ç½®
                this.levelConfigs = [
                    { level: 1, name: 'ç®€å•', emojiTypes: 8, repetitionRate: 0.15, cardMultiplier: 0.8, shuffleRate: 0.2 },
                    { level: 2, name: 'ç®€å•', emojiTypes: 9, repetitionRate: 0.18, cardMultiplier: 0.85, shuffleRate: 0.3 },
                    { level: 3, name: 'æ™®é€š', emojiTypes: 10, repetitionRate: 0.22, cardMultiplier: 0.9, shuffleRate: 0.4 },
                    { level: 4, name: 'æ™®é€š', emojiTypes: 11, repetitionRate: 0.25, cardMultiplier: 0.95, shuffleRate: 0.5 },
                    { level: 5, name: 'æ™®é€š', emojiTypes: 12, repetitionRate: 0.28, cardMultiplier: 1.0, shuffleRate: 0.6 },
                    { level: 6, name: 'å›°éš¾', emojiTypes: 13, repetitionRate: 0.32, cardMultiplier: 1.05, shuffleRate: 0.7 },
                    { level: 7, name: 'å›°éš¾', emojiTypes: 14, repetitionRate: 0.35, cardMultiplier: 1.1, shuffleRate: 0.8 },
                    { level: 8, name: 'å›°éš¾', emojiTypes: 15, repetitionRate: 0.38, cardMultiplier: 1.15, shuffleRate: 0.85 },
                    { level: 9, name: 'ä¸“å®¶', emojiTypes: 16, repetitionRate: 0.42, cardMultiplier: 1.2, shuffleRate: 0.9 },
                    { level: 10, name: 'ä¸“å®¶', emojiTypes: 18, repetitionRate: 0.45, cardMultiplier: 1.25, shuffleRate: 0.95 }
                ];
                this.modalListenersAdded = false;
                // åˆå§‹åŒ–æ˜¾ç¤ºå°ºå¯¸é»˜è®¤å€¼
                this.canvasDisplayWidth = 800;
                this.canvasDisplayHeight = 600;
                this.setupCanvas();
                this.init();
                this.bindEvents();
                this.initSlots();
            }

            setupCanvas() {
                // åŠ¨æ€è®¾ç½®canvaså°ºå¯¸ä»¥é€‚åº”çˆ¶å®¹å™¨
                const updateCanvasSize = () => {
                    const container = this.canvas.parentElement;
                    const containerRect = container.getBoundingClientRect();
                    
                    // è·å–çˆ¶å®¹å™¨çš„å®é™…å¯ç”¨å°ºå¯¸
                    const availableWidth = containerRect.width;
                    const availableHeight = containerRect.height;
                    
                    // è·å–è®¾å¤‡åƒç´ æ¯”ï¼Œç¡®ä¿æ¸…æ™°åº¦
                    const devicePixelRatio = window.devicePixelRatio || 1;
                    
                    // è®¾ç½®canvasçš„æ˜¾ç¤ºå°ºå¯¸ï¼ˆCSSå°ºå¯¸ï¼‰
                    this.canvas.style.width = availableWidth + 'px';
                    this.canvas.style.height = availableHeight + 'px';
                    
                    // è®¾ç½®canvasçš„å®é™…å°ºå¯¸ï¼ˆç»˜åˆ¶å°ºå¯¸ï¼‰ï¼Œè€ƒè™‘è®¾å¤‡åƒç´ æ¯”ä»¥ä¿æŒæ¸…æ™°åº¦
                    this.canvas.width = availableWidth * devicePixelRatio;
                    this.canvas.height = availableHeight * devicePixelRatio;
                    
                    // é‡ç½®å˜æ¢çŸ©é˜µï¼Œç„¶åç¼©æ”¾ç»˜åˆ¶ä¸Šä¸‹æ–‡ä»¥åŒ¹é…è®¾å¤‡åƒç´ æ¯”
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.scale(devicePixelRatio, devicePixelRatio);
                    
                    // å­˜å‚¨æ˜¾ç¤ºå°ºå¯¸ä¾›åæ ‡è®¡ç®—ä½¿ç”¨
                    this.canvasDisplayWidth = availableWidth;
                    this.canvasDisplayHeight = availableHeight;
                    
                    // é‡æ–°å¸ƒå±€å’Œç»˜åˆ¶æ¸¸æˆ
                    if (this.cards && this.cards.length > 0) {
                        this.relayoutCards();
                        this.draw();
                    }
                };
                
                // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿DOMå®Œå…¨æ¸²æŸ“
                setTimeout(updateCanvasSize, 10);
                window.addEventListener('resize', updateCanvasSize);
                window.addEventListener('orientationchange', () => {
                    setTimeout(updateCanvasSize, 100);
                });
            }

            init() {
                this.updateLevelDisplay();
                this.createCards();
                
                // å¯åŠ¨æ—¶è‡ªåŠ¨æ£€æŸ¥å¡ç‰Œç”Ÿæˆæ˜¯å¦æ­£ç¡®
                setTimeout(() => {
                    this.performStartupValidation();
                }, 2000);
                
                this.updateClickableStatus();
                this.draw();
            }

            // å¯åŠ¨æ—¶éªŒè¯å¡ç‰Œç”Ÿæˆçš„æ­£ç¡®æ€§
            performStartupValidation() {
                console.log('=== å¯åŠ¨æ—¶éªŒè¯å¡ç‰Œç”Ÿæˆ ===');
                let attempts = 0;
                const maxAttempts = 5;
                
                while (attempts < maxAttempts) {
                    attempts++;
                    console.log(`ç¬¬${attempts}æ¬¡éªŒè¯`);
                    
                    // æ£€æŸ¥å½“å‰ç”Ÿæˆçš„å¡ç‰Œæ˜¯å¦æ­£ç¡®
                    const validationResult = this.validateCardGeneration();
                    
                    if (validationResult.isValid) {
                        console.log('âœ… éªŒè¯é€šè¿‡ï¼å¡ç‰Œç”Ÿæˆæ­£ç¡®ï¼Œæ‰€æœ‰emojiéƒ½æ˜¯3çš„å€æ•°');
                        console.log('éªŒè¯ç»“æœ:', validationResult);
                        return;
                    } else {
                        console.log(`âŒ ç¬¬${attempts}æ¬¡éªŒè¯å¤±è´¥:`, validationResult.errors);
                        console.log('é‡æ–°ç”Ÿæˆå¡ç‰Œ...');
                        
                        // æ¸…ç©ºå½“å‰å¡ç‰Œï¼Œé‡æ–°ç”Ÿæˆ
                        this.cards = [];
                        this.createCards();
                    }
                }
                
                console.error(`âŒ ç»è¿‡${maxAttempts}æ¬¡å°è¯•ä»æ— æ³•ç”Ÿæˆæ­£ç¡®çš„å¡ç‰Œï¼ä½¿ç”¨ç´§æ€¥ä¿®å¤æ¨¡å¼`);
                this.forceFixCardGeneration();
            }

            // éªŒè¯å¡ç‰Œç”Ÿæˆæ˜¯å¦æ­£ç¡®
            validateCardGeneration() {
                // ç»Ÿè®¡æ‰€æœ‰å¡ç‰Œä¸­æ¯ç§emojiçš„æ•°é‡
                const emojiCounts = {};
                this.cards.forEach(card => {
                    emojiCounts[card.emoji] = (emojiCounts[card.emoji] || 0) + 1;
                });
                
                const errors = [];
                let totalCards = 0;
                let validGroups = 0;
                
                // æ£€æŸ¥æ¯ç§emojiçš„æ•°é‡æ˜¯å¦æ˜¯3çš„å€æ•°
                Object.entries(emojiCounts).forEach(([emoji, count]) => {
                    totalCards += count;
                    if (count % 3 !== 0) {
                        errors.push(`${emoji}: ${count}å¼  (ä¸æ˜¯3çš„å€æ•°ï¼Œä½™æ•°${count % 3})`);
                    } else {
                        validGroups += count / 3;
                    }
                });
                
                const isValid = errors.length === 0;
                
                return {
                    isValid,
                    errors,
                    totalCards,
                    totalEmojis: Object.keys(emojiCounts).length,
                    validGroups,
                    emojiCounts
                };
            }

            // å¼ºåˆ¶ä¿®å¤å¡ç‰Œç”Ÿæˆ
            forceFixCardGeneration() {
                console.log('=== å¼ºåˆ¶ä¿®å¤å¡ç‰Œç”Ÿæˆ ===');
                
                // ä½¿ç”¨æœ€ç®€å•å¯é çš„æ–¹æ³•é‡æ–°ç”Ÿæˆ
                const levelConfig = this.levelConfigs[this.currentLevel - 1];
                const availableEmojis = this.emojis.slice(0, 6); // åªä½¿ç”¨å‰6ç§emojiç¡®ä¿å®‰å…¨
                
                // è®¡ç®—åˆç†çš„å¡ç‰Œæ€»æ•°ï¼ˆç¡®ä¿æ˜¯3çš„å€æ•°ï¼‰
                const targetCards = Math.floor(this.cards.length / 3) * 3;
                const groupsNeeded = targetCards / 3;
                
                console.log(`ç›®æ ‡å¡ç‰Œæ•°: ${targetCards} (${groupsNeeded}ç»„)`);
                
                // æ¸…ç©ºç°æœ‰å¡ç‰Œ
                this.cards = [];
                
                // é‡æ–°ç”Ÿæˆå¡ç‰Œemojiæ•°ç»„
                const cardEmojis = [];
                
                // å¹³å‡åˆ†é…ç»„æ•°åˆ°æ¯ç§emoji
                const groupsPerEmoji = Math.floor(groupsNeeded / availableEmojis.length);
                const remainingGroups = groupsNeeded % availableEmojis.length;
                
                availableEmojis.forEach((emoji, index) => {
                    const groupsForThisEmoji = groupsPerEmoji + (index < remainingGroups ? 1 : 0);
                    
                    for (let i = 0; i < groupsForThisEmoji; i++) {
                        for (let j = 0; j < 3; j++) {
                            cardEmojis.push(emoji);
                        }
                    }
                });
                
                // æ‰“ä¹±æ•°ç»„
                for (let i = cardEmojis.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [cardEmojis[i], cardEmojis[j]] = [cardEmojis[j], cardEmojis[i]];
                }
                
                // é‡æ–°ç”Ÿæˆå¡ç‰Œä½ç½®
                let emojiIndex = 0;
                const layerSizes = [20, 25, 30, 35, 30, 25, 20]; // å›ºå®šçš„å±‚çº§åˆ†å¸ƒ
                
                for (let layerIndex = layerSizes.length - 1; layerIndex >= 0; layerIndex--) {
                    const size = Math.min(layerSizes[layerIndex], cardEmojis.length - emojiIndex);
                    if (size <= 0) break;
                    
                    const positions = this.generateCompactPositions(size, layerIndex, layerSizes.length);
                    
                    positions.forEach(pos => {
                        if (emojiIndex < cardEmojis.length) {
                            const emoji = cardEmojis[emojiIndex++];
                            this.cards.push(new Card(pos.x, pos.y, layerIndex, emoji, {width: this.canvasDisplayWidth, height: this.canvasDisplayHeight}));
                        }
                    });
                }
                
                // æœ€ç»ˆéªŒè¯
                const finalValidation = this.validateCardGeneration();
                if (finalValidation.isValid) {
                    console.log('âœ… å¼ºåˆ¶ä¿®å¤æˆåŠŸï¼');
                } else {
                    console.error('âŒ å¼ºåˆ¶ä¿®å¤å¤±è´¥ï¼', finalValidation.errors);
                }
            }

            initSlots() {
                const slotContainer = document.getElementById('slotContainer');
                slotContainer.innerHTML = '';
                for (let i = 0; i < this.maxSlots; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'slot-card';
                    slot.id = `slot-${i}`;
                    slotContainer.appendChild(slot);
                }
            }

            createCards() {
                // è·å–å½“å‰å…³å¡é…ç½®
                const levelConfig = this.levelConfigs[this.currentLevel - 1];
                
                // æ¯å±‚ä½¿ç”¨éšæœºæ•°é‡çš„å¡ç‰Œï¼ŒåŸºäºå…³å¡é…ç½®è°ƒæ•´
                let layerSizes = [];
                const baseMinCards = 20; // åŸºç¡€æ¯å±‚æœ€å°‘å¡ç‰Œæ•°
                const baseMaxCards = 40; // åŸºç¡€æ¯å±‚æœ€å¤šå¡ç‰Œæ•°
                
                for (let i = 0; i < 7; i++) {
                    // ç”Ÿæˆæ¯å±‚çš„éšæœºå¡ç‰Œæ•°é‡ï¼Œä¸­é—´å±‚æ¬¡å¤šä¸€äº›
                    let rangeMin, rangeMax;
                    if (i === 3) {
                        // ä¸­é—´å±‚ï¼ˆç¬¬3å±‚ï¼‰å¡ç‰Œæœ€å¤š
                        rangeMin = 35;
                        rangeMax = 45;
                    } else if (i === 2 || i === 4) {
                        // æ¬¡ä¸­é—´å±‚
                        rangeMin = 30;
                        rangeMax = 40;
                    } else if (i === 1 || i === 5) {
                        // è¾¹ç¼˜å±‚
                        rangeMin = 25;
                        rangeMax = 35;
                    } else {
                        // æœ€å¤–å±‚
                        rangeMin = baseMinCards;
                        rangeMax = 30;
                    }
                    
                    // æ ¹æ®å…³å¡è°ƒæ•´å¡ç‰Œæ•°é‡
                    rangeMin = Math.floor(rangeMin * levelConfig.cardMultiplier);
                    rangeMax = Math.floor(rangeMax * levelConfig.cardMultiplier);
                    
                    const randomCount = Math.floor(Math.random() * (rangeMax - rangeMin + 1)) + rangeMin;
                    layerSizes.push(randomCount);
                }
                
                let totalCards = layerSizes.reduce((sum, size) => sum + size, 0);
                
                // ç¡®ä¿æ€»å¡ç‰Œæ•°æ˜¯3çš„å€æ•°ï¼Œé¿å…åç»­ç”Ÿæˆé—®é¢˜
                totalCards = Math.floor(totalCards / 3) * 3;
                
                // æ ¹æ®å…³å¡é€‰æ‹©emojiç§ç±»
                const availableEmojis = this.emojis.slice(0, levelConfig.emojiTypes);
                
                // ç”Ÿæˆç¡®ä¿å¯æ¶ˆé™¤çš„å¡ç‰Œæ•°ç»„ï¼ˆæ–°çš„ä¼˜åŒ–æ–¹æ³•ï¼‰
                const cardEmojis = this.generateSolvableCards(totalCards, availableEmojis, levelConfig);
                
                // æ›´æ–°æ€»å¡ç‰Œæ•°ï¼ˆä½¿ç”¨å®é™…ç”Ÿæˆçš„æ•°é‡ï¼‰
                const actualTotalCards = cardEmojis.length;
                
                // è°ƒæ•´layerSizesä»¥åŒ¹é…cardEmojisçš„é•¿åº¦
                if (totalCards !== actualTotalCards) {
                    console.log(`è°ƒæ•´layerSizes: ${totalCards} -> ${actualTotalCards}`);
                    
                    // æŒ‰æ¯”ä¾‹è°ƒæ•´å±‚çº§åˆ†å¸ƒ
                    const originalTotal = totalCards;
                    const ratio = actualTotalCards / originalTotal;
                    
                    const newLayerSizes = [];
                    let remainingCards = actualTotalCards;
                    
                    for (let i = 0; i < layerSizes.length - 1; i++) {
                        const adjustedSize = Math.floor(layerSizes[i] * ratio);
                        newLayerSizes.push(adjustedSize);
                        remainingCards -= adjustedSize;
                    }
                    
                    // æœ€åä¸€å±‚åˆ†é…æ‰€æœ‰å‰©ä½™å¡ç‰Œ
                    newLayerSizes.push(Math.max(0, remainingCards));
                    
                    layerSizes = newLayerSizes;
                    console.log('è°ƒæ•´åçš„layerSizes:', layerSizes);
                }
                
                let emojiIndex = 0;
                
                // ä»é¡¶å±‚å¼€å§‹ç”Ÿæˆï¼ˆç¬¬6å±‚åˆ°ç¬¬0å±‚ï¼‰
                for (let layerIndex = layerSizes.length - 1; layerIndex >= 0; layerIndex--) {
                    const size = layerSizes[layerIndex];
                    if (size <= 0) continue;
                    
                    console.log(`ç”Ÿæˆç¬¬${layerIndex}å±‚ï¼Œéœ€è¦${size}å¼ å¡ç‰Œï¼Œå½“å‰emojiIndex: ${emojiIndex}`);
                    
                    const positions = this.generateCompactPositions(size, layerIndex, layerSizes.length);
                    console.log(`ç¬¬${layerIndex}å±‚ç”Ÿæˆäº†${positions.length}ä¸ªä½ç½®`);
                    
                    if (positions.length !== size) {
                        console.warn(`è­¦å‘Šï¼šç¬¬${layerIndex}å±‚ä½ç½®æ•°(${positions.length})ä¸éœ€æ±‚(${size})ä¸åŒ¹é…`);
                        // å¦‚æœä½ç½®æ•°ä¸åŒ¹é…ï¼Œä½¿ç”¨å®é™…ç”Ÿæˆçš„ä½ç½®æ•°
                        console.log(`ä½¿ç”¨å®é™…ä½ç½®æ•°: ${positions.length}`);
                    }
                    
                    // ä½¿ç”¨å®é™…ç”Ÿæˆçš„ä½ç½®æ•°ï¼Œé¿å…è¶Šç•Œ
                    const actualPositionsToUse = Math.min(positions.length, cardEmojis.length - emojiIndex);
                    console.log(`ç¬¬${layerIndex}å±‚å®é™…ä½¿ç”¨ä½ç½®æ•°: ${actualPositionsToUse}, å‰©ä½™emoji: ${cardEmojis.length - emojiIndex}`);
                    
                    for (let i = 0; i < actualPositionsToUse; i++) {
                        const pos = positions[i];
                        if (emojiIndex < cardEmojis.length) {
                            const emoji = cardEmojis[emojiIndex];
                            this.cards.push(new Card(pos.x, pos.y, layerIndex, emoji, {width: this.canvasDisplayWidth, height: this.canvasDisplayHeight}));
                            emojiIndex++; // åœ¨æˆåŠŸåˆ›å»ºå¡ç‰Œåæ‰å¢åŠ ç´¢å¼•
                        } else {
                            console.error(`é”™è¯¯ï¼šemojiIndex(${emojiIndex})å·²è¾¾åˆ°æˆ–è¶…å‡ºcardEmojisé•¿åº¦(${cardEmojis.length})ï¼Œåœæ­¢ç”Ÿæˆç¬¬${layerIndex}å±‚å‰©ä½™å¡ç‰Œ`);
                            break; // è·³å‡ºå½“å‰å±‚çš„å¾ªç¯
                        }
                    }
                    
                    // å¦‚æœemojiå·²ç»ç”¨å®Œï¼Œåœæ­¢ç”Ÿæˆåç»­å±‚
                    if (emojiIndex >= cardEmojis.length) {
                        console.log(`æ‰€æœ‰emojiå·²åˆ†é…å®Œæ¯•ï¼Œåœæ­¢ç”Ÿæˆåç»­å±‚çº§`);
                        break;
                    }
                }
                
                // éªŒè¯æ‰€æœ‰å¡ç‰Œéƒ½è¢«åˆ†é…
                console.log(`ç”Ÿæˆçš„å¡ç‰Œæ€»æ•°: ${this.cards.length}`);
                console.log(`é¢„æœŸå¡ç‰Œæ€»æ•°: ${actualTotalCards}`);
                console.log(`ä½¿ç”¨çš„emojiæ•°é‡: ${emojiIndex}`);
                console.log(`å¯ç”¨emojiæ•°é‡: ${cardEmojis.length}`);
                
                if (this.cards.length !== actualTotalCards) {
                    console.error(`ä¸¥é‡é”™è¯¯ï¼šå®é™…ç”Ÿæˆçš„å¡ç‰Œæ•°(${this.cards.length})ä¸ç­‰äºé¢„æœŸæ•°é‡(${actualTotalCards})`);
                }
                
                if (emojiIndex !== cardEmojis.length) {
                    console.error(`ä¸¥é‡é”™è¯¯ï¼šä½¿ç”¨çš„emojiæ•°é‡(${emojiIndex})ä¸ç­‰äºå¯ç”¨æ•°é‡(${cardEmojis.length})`);
                }
                
                // ä¿æŒå±‚çº§æ’åºï¼ˆå…ˆç»˜åˆ¶ä½å±‚çº§ï¼‰
                this.cards.sort((a, b) => a.layer - b.layer);
            }
            
            generateCompactPositions(cardCount, layer, totalLayers) {
                const positions = [];
                // åŠ¨æ€è®¡ç®—å¡ç‰Œå°ºå¯¸ - ä½¿ç”¨æ˜¾ç¤ºå°ºå¯¸è¿›è¡Œåæ ‡è®¡ç®—
                const canvasDisplayWidth = this.canvasDisplayWidth;
                const canvasDisplayHeight = this.canvasDisplayHeight;
                
                const baseSize = Math.min(canvasDisplayWidth / 18, canvasDisplayHeight / 12, 65);
                const cardWidth = Math.max(30, baseSize);
                const cardHeight = Math.max(30, baseSize);
                const cardSpacing = Math.max(1, cardWidth * 0.02); // æ ¹æ®å¡ç‰Œå¤§å°è°ƒæ•´é—´è·
                
                // è®¡ç®—canvasä¸­å¿ƒç‚¹ - ä½¿ç”¨æ˜¾ç¤ºå°ºå¯¸ï¼Œæ•´ä½“å‘å³åç§»
                const rightOffset = canvasDisplayWidth * 0; // å‘å³åç§»10%çš„å®½åº¦
                const centerX = canvasDisplayWidth / 2 + rightOffset;
                const centerY = canvasDisplayHeight / 2;
                
                // æ ¹æ®å±‚çº§è®¡ç®—Yåæ ‡ï¼ŒåŠ¨æ€è°ƒæ•´é—´è·å’Œåç§»
                const layerSpacing = Math.min(cardHeight * 0.85, canvasDisplayHeight / (totalLayers + 2)); // åŠ¨æ€è°ƒæ•´å±‚çº§é—´è·
                const yOffset = -canvasDisplayHeight * 0.2; // åŠ¨æ€å‘ä¸Šåç§»
                const yBase = centerY - (totalLayers - 1) * layerSpacing / 2 + layer * layerSpacing + yOffset;
                
                // è®¡ç®—æ¯è¡Œæœ€å¤šèƒ½æ”¾å¤šå°‘å¼ å¡ç‰Œï¼ˆç´§å‡‘å±…ä¸­æ’åˆ—ï¼‰
                const cardsPerRow = Math.min(cardCount, 11); // å¢åŠ æ¯è¡Œå¡ç‰Œæ•°
                const rows = Math.ceil(cardCount / cardsPerRow);
                
                // é€‚åº¦æ¨ªå‘å±‚çº§é”™å¼€æ•ˆæœ
                const horizontalOffset = cardWidth * (layer % 2 === 0 ? 0.6 : -0.6); // å¶æ•°å±‚å³ç§»ï¼Œå¥‡æ•°å±‚å·¦ç§»ï¼ŒåŠ¨æ€è°ƒæ•´é”™å¼€è·ç¦»
                
                // ç¨å¾®å¢åŠ ç«–å‘å±‚çº§é”™å¼€æ•ˆæœ
                const verticalOffset = cardHeight * (layer % 3 === 0 ? 0.8 : layer % 3 === 1 ? -0.4 : 0.4); // 3å±‚ä¸€ä¸ªå¾ªç¯ï¼ŒåŠ¨æ€è°ƒæ•´é”™å¼€è·ç¦»
                
                // æ ¹æ®å±‚çº§è°ƒæ•´æ¯è¡Œçš„å±…ä¸­ä½ç½®
                const layerWidthRatio = this.getLayerWidthRatio(layer, totalLayers);
                const adjustedCardsPerRow = Math.max(1, Math.floor(cardsPerRow * layerWidthRatio));
                
                let totalCardsPlaced = 0;
                for (let row = 0; row < rows; row++) {
                    const cardsInThisRow = Math.min(adjustedCardsPerRow, cardCount - totalCardsPlaced);
                    if (cardsInThisRow <= 0) break;
                    
                    const rowWidth = cardsInThisRow * (cardWidth + cardSpacing) - cardSpacing;
                    
                    // è®¡ç®—è¯¥è¡Œçš„èµ·å§‹Xåæ ‡ï¼ˆå±…ä¸­ + æ¨ªå‘å±‚çº§é”™å¼€ + å®½åº¦æ¯”ä¾‹è°ƒæ•´ï¼‰
                    const rowStartX = centerX - rowWidth / 2 + horizontalOffset;
                    
                    for (let col = 0; col < cardsInThisRow; col++) {
                        // ç´§å‡‘æ’åˆ—ï¼Œæœ€å°é—´è· + ç«–å‘å±‚çº§é”™å¼€
                        const x = rowStartX + col * (cardWidth + cardSpacing);
                        const y = yBase + row * (cardHeight + cardSpacing) + verticalOffset;
                        
                        positions.push({x, y});
                        totalCardsPlaced++;
                    }
                }
                
                // ç¡®ä¿ç”Ÿæˆäº†è¶³å¤Ÿçš„ä½ç½®
                if (positions.length !== cardCount) {
                    console.warn(`ç¬¬${layer}å±‚ï¼šéœ€è¦${cardCount}ä¸ªä½ç½®ï¼Œå®é™…ç”Ÿæˆ${positions.length}ä¸ªä½ç½®`);
                    
                    // å¦‚æœä½ç½®ä¸å¤Ÿï¼Œé‡æ–°è®¡ç®—æ›´åˆç†çš„å¸ƒå±€
                    const remaining = cardCount - positions.length;
                    console.log(`ç¬¬${layer}å±‚ï¼šéœ€è¦è¡¥å……${remaining}ä¸ªä½ç½®`);
                    
                    // é‡æ–°è®¡ç®—è¡Œæ•°å’Œæ¯è¡Œå¡ç‰Œæ•°ï¼Œç¡®ä¿å¸ƒå±€æ›´ç´§å‡‘
                    const newCardsPerRow = Math.min(cardCount, Math.ceil(Math.sqrt(cardCount * 1.5))); // é€‚ä¸­çš„æ¯è¡Œå¡ç‰Œæ•°
                    const newRows = Math.ceil(cardCount / newCardsPerRow);
                    
                    // æ¸…ç©ºåŸæœ‰ä½ç½®ï¼Œé‡æ–°ç”Ÿæˆæ›´åˆç†çš„å¸ƒå±€
                    positions.length = 0;
                    
                    for (let row = 0; row < newRows; row++) {
                        const cardsInThisRow = Math.min(newCardsPerRow, cardCount - row * newCardsPerRow);
                        const rowWidth = cardsInThisRow * (cardWidth + cardSpacing) - cardSpacing;
                        const rowStartX = centerX - rowWidth / 2 + horizontalOffset;
                        
                        for (let col = 0; col < cardsInThisRow; col++) {
                            const x = rowStartX + col * (cardWidth + cardSpacing);
                            const y = yBase + row * (cardHeight + cardSpacing) + verticalOffset;
                            positions.push({x, y});
                        }
                    }
                    
                    console.log(`ç¬¬${layer}å±‚ï¼šé‡æ–°å¸ƒå±€åå…±${positions.length}ä¸ªä½ç½®ï¼Œ${newRows}è¡Œï¼Œæ¯è¡Œæœ€å¤š${newCardsPerRow}å¼ `);
                }
                
                return positions;
            }
            
            getLayerWidthRatio(layer, totalLayers) {
                // åŒæ¼æ–—ç»“æ„çš„å®½åº¦æ¯”ä¾‹ (7å±‚)
                const ratios = [0.4, 0.6, 0.8, 1.0, 0.8, 0.6, 0.4]; // ä»åº•å±‚åˆ°é¡¶å±‚çš„å®½åº¦æ¯”ä¾‹
                return ratios[layer] || 1.0;
            }

            relayoutCards() {
                // é‡æ–°è®¡ç®—æ‰€æœ‰å¡ç‰Œçš„ä½ç½®ï¼Œä¿æŒåŸæœ‰çš„æ¸¸æˆçŠ¶æ€
                if (!this.cards || this.cards.length === 0) return;
                
                // æŒ‰å±‚çº§é‡æ–°åˆ†ç»„ç°æœ‰å¡ç‰Œ
                const cardsByLayer = {};
                this.cards.forEach(card => {
                    if (!cardsByLayer[card.layer]) {
                        cardsByLayer[card.layer] = [];
                    }
                    cardsByLayer[card.layer].push(card);
                });
                
                // ä¸ºæ¯ä¸€å±‚é‡æ–°è®¡ç®—ä½ç½®
                Object.keys(cardsByLayer).forEach(layerIndex => {
                    const layerCards = cardsByLayer[layerIndex];
                    const layer = parseInt(layerIndex);
                    const totalLayers = Math.max(...Object.keys(cardsByLayer).map(l => parseInt(l))) + 1;
                    
                    // ç”Ÿæˆæ–°ä½ç½®
                    const newPositions = this.generateCompactPositions(layerCards.length, layer, totalLayers);
                    
                    // æ›´æ–°å¡ç‰Œä½ç½®å’Œå°ºå¯¸
                    layerCards.forEach((card, index) => {
                        if (index < newPositions.length) {
                            card.x = newPositions[index].x;
                            card.y = newPositions[index].y;
                            
                            // é‡æ–°è®¡ç®—å¡ç‰Œå°ºå¯¸
                            const baseSize = Math.min(this.canvasDisplayWidth / 18, this.canvasDisplayHeight / 12, 65);
                            card.width = Math.max(30, baseSize);
                            card.height = Math.max(30, baseSize);
                        }
                    });
                });
                
                // é‡æ–°è®¡ç®—é®æŒ¡çŠ¶æ€
                this.updateClickableStatus();
            }

            updateClickableStatus() {
                // é‡ç½®æ‰€æœ‰å¡ç‰Œçš„çŠ¶æ€
                this.cards.forEach(card => {
                    card.isClickable = false;
                    card.isBlocked = false;
                });

                // ä»é«˜å±‚åˆ°ä½å±‚æ£€æŸ¥é®æŒ¡å…³ç³»
                for (let i = this.cards.length - 1; i >= 0; i--) {
                    const card = this.cards[i];
                    if (!card.visible) continue;

                    let isBlocked = false;
                    
                    // æ£€æŸ¥æ˜¯å¦è¢«ä¸Šå±‚çš„å¡ç‰Œé®æŒ¡
                    for (let j = i + 1; j < this.cards.length; j++) {
                        const upperCard = this.cards[j];
                        if (!upperCard.visible) continue;
                        
                        if (this.isCardBlocked(card, upperCard)) {
                            isBlocked = true;
                            break;
                        }
                    }

                    // è®¾ç½®é®æŒ¡çŠ¶æ€å’Œç‚¹å‡»çŠ¶æ€
                    card.isBlocked = isBlocked;
                    if (!isBlocked) {
                        card.isClickable = true;
                    }
                }
            }

            isCardBlocked(lowerCard, upperCard) {
                // ç²¾ç¡®çš„åƒç´ çº§é®æŒ¡æ£€æµ‹ï¼šæ£€æŸ¥ä¸¤ä¸ªå¡ç‰Œæ˜¯å¦æœ‰é‡å åŒºåŸŸ
                const lowerLeft = lowerCard.x;
                const lowerRight = lowerCard.x + lowerCard.width;
                const lowerTop = lowerCard.y;
                const lowerBottom = lowerCard.y + lowerCard.height;
                
                const upperLeft = upperCard.x;
                const upperRight = upperCard.x + upperCard.width;
                const upperTop = upperCard.y;
                const upperBottom = upperCard.y + upperCard.height;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰é‡å 
                const horizontalOverlap = lowerLeft < upperRight && lowerRight > upperLeft;
                const verticalOverlap = lowerTop < upperBottom && lowerBottom > upperTop;
                
                // å¦‚æœæœ‰ä»»æ„é‡å ï¼Œåˆ™è®¤ä¸ºè¢«é®æŒ¡
                return horizontalOverlap && verticalOverlap;
            }

            bindEvents() {
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    // è®¡ç®—ç›¸å¯¹äºcanvasæ˜¾ç¤ºå°ºå¯¸çš„åæ ‡
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.handleClick(x, y);
                });
            }

            handleClick(x, y) {
                // ä»é«˜å±‚åˆ°ä½å±‚æŸ¥æ‰¾ç‚¹å‡»çš„å¡ç‰Œ
                for (let i = this.cards.length - 1; i >= 0; i--) {
                    const card = this.cards[i];
                    if (card.visible && card.isClickable && card.isPointInside(x, y)) {
                        this.removeCard(card);
                        break;
                    }
                }
            }

            removeCard(card) {
                // ä»æ¸¸æˆåŒºåŸŸç§»é™¤å¡ç‰Œ
                card.visible = false;
                
                // æ·»åŠ åˆ°æ§½ä½
                this.addToSlot(card);
                
                // æ›´æ–°æ‰€æœ‰å¡ç‰Œçš„å¯ç‚¹å‡»çŠ¶æ€
                this.updateClickableStatus();
                this.draw();
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                this.checkGameEnd();
            }

            addToSlot(card) {
                console.log(`æ·»åŠ å¡ç‰Œåˆ°æ§½ä½: ${card.emoji}`);
                console.log(`æ§½ä½æ·»åŠ å‰çŠ¶æ€: [${this.slots.map((c, idx) => `${idx}:${c.emoji}`).join(', ')}]`);
                
                // æ£€æŸ¥æ§½ä½æ˜¯å¦å·²æ»¡ï¼Œå¦‚æœæ»¡äº†åˆ™æ¸¸æˆå¤±è´¥
                if (this.slots.length >= this.maxSlots) {
                    this.gameOver(true);
                    return;
                }

                // æŸ¥æ‰¾ç›¸åŒemojiçš„å¡ç‰Œåœ¨æ§½ä½ä¸­çš„ä½ç½®
                const sameEmojiIndex = this.slots.findIndex(slotCard => slotCard.emoji === card.emoji);
                
                let newCardIndex;
                if (sameEmojiIndex !== -1) {
                    // æ‰¾åˆ°ç›¸åŒemojiçš„å¡ç‰Œï¼Œæ’å…¥åˆ°å…¶æœ€åä¸€å¼ çš„å°¾éƒ¨
                    let insertIndex = sameEmojiIndex;
                    for (let i = sameEmojiIndex; i < this.slots.length; i++) {
                        if (this.slots[i].emoji === card.emoji) {
                            insertIndex = i + 1;
                        } else {
                            break;
                        }
                    }
                    this.slots.splice(insertIndex, 0, card);
                    newCardIndex = insertIndex;
                } else {
                    // æ²¡æœ‰æ‰¾åˆ°ç›¸åŒemojiçš„å¡ç‰Œï¼Œæ·»åŠ åˆ°æœ«å°¾
                    this.slots.push(card);
                    newCardIndex = this.slots.length - 1;
                }
                
                // æ›´æ–°æ§½ä½æ˜¾ç¤ºï¼Œå¹¶æŒ‡å®šæ–°å¡ç‰Œçš„ç´¢å¼•ç”¨äºåŠ¨ç”»
                this.updateSlotDisplay(newCardIndex);
                
                console.log(`æ§½ä½æ·»åŠ åçŠ¶æ€: [${this.slots.map((c, idx) => `${idx}:${c.emoji}`).join(', ')}]`);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰3å¼ ç›¸åŒçš„å¡ç‰Œ
                this.checkSlotMatch();
                
                // å¦‚æœæ§½ä½åˆšå¥½è¾¾åˆ°æœ€å¤§å€¼ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å¯æ¶ˆé™¤çš„å¡ç‰Œ
                if (this.slots.length >= this.maxSlots) {
                    // æ£€æŸ¥å½“å‰æ§½ä½ä¸­æ˜¯å¦æœ‰å¯æ¶ˆé™¤çš„ç»„åˆ
                    if (!this.hasSlotMatch()) {
                        this.gameOver(true);
                        return;
                    }
                }
            }

            updateSlotDisplay(newCardIndex = -1) {
                const slotContainer = document.getElementById('slotContainer');
                const slotElements = slotContainer.children;
                
                // æ¸…ç©ºæ‰€æœ‰æ§½ä½
                for (let i = 0; i < slotElements.length; i++) {
                    const slot = slotElements[i];
                    slot.textContent = '';
                    slot.className = 'slot-card';
                }
                
                // å¡«å……æ§½ä½
                this.slots.forEach((card, index) => {
                    if (index < this.maxSlots) {
                        const slot = slotElements[index];
                        slot.textContent = card.emoji;
                        
                        // åªæœ‰æ–°æ·»åŠ çš„å¡ç‰Œæ‰æ’­æ”¾åŠ¨ç”»
                        if (index === newCardIndex) {
                            slot.className = 'slot-card adding';
                            
                            // æ·»åŠ å®ŒæˆåŠ¨ç”»åç§»é™¤åŠ¨ç”»ç±»
                            setTimeout(() => {
                                slot.classList.remove('adding');
                            }, 500);
                        } else {
                            slot.className = 'slot-card';
                        }
                    }
                });
                
                // å¦‚æœæ§½ä½æ¥è¿‘æ»¡ï¼Œæ·»åŠ è­¦å‘Šæ•ˆæœ
                if (this.slots.length >= this.maxSlots - 1) {
                    for (let i = 0; i < slotElements.length; i++) {
                        if (i >= this.slots.length) {
                            slotElements[i].classList.add('warning');
                        }
                    }
                }
            }

            checkSlotMatch() {
                // å¦‚æœæ­£åœ¨ç§»é™¤ä¸­ï¼Œè·³è¿‡æ£€æŸ¥ï¼Œé˜²æ­¢ç«æ€æ¡ä»¶
                if (this.isRemoving) {
                    console.log('æ­£åœ¨ç§»é™¤ä¸­ï¼Œè·³è¿‡æ§½ä½æ£€æŸ¥');
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰3å¼ è¿ç»­çš„ç›¸åŒemoji
                for (let i = 0; i <= this.slots.length - 3; i++) {
                    if (this.slots[i].emoji === this.slots[i + 1].emoji && 
                        this.slots[i].emoji === this.slots[i + 2].emoji) {
                        console.log(`å‘ç°3å¼ è¿ç»­ç›¸åŒå¡ç‰Œ: ${this.slots[i].emoji} at positions [${i}, ${i+1}, ${i+2}]`);
                        console.log(`æ§½ä½æ¶ˆé™¤å‰çŠ¶æ€: [${this.slots.map((c, idx) => `${idx}:${c.emoji}`).join(', ')}]`);
                        this.removeSlotMatch(i, i + 1, i + 2);
                        return;
                    }
                }
            }

            removeSlotMatch(index1, index2, index3) {
                // è®¾ç½®ç§»é™¤æ ‡å¿—ï¼Œé˜²æ­¢é‡å¤è°ƒç”¨
                this.isRemoving = true;
                
                const emoji = this.slots[index1].emoji;
                console.log(`å¼€å§‹ç§»é™¤æµç¨‹ï¼Œè®¾ç½®isRemoving=true`);
                
                // æ·»åŠ æ¶ˆé™¤åŠ¨ç”»
                const slotContainer = document.getElementById('slotContainer');
                const slotElements = slotContainer.children;
                
                [index1, index2, index3].forEach(index => {
                    if (slotElements[index]) {
                        slotElements[index].classList.add('removing');
                    }
                });
                
                // ç­‰å¾…åŠ¨ç”»å®Œæˆåç§»é™¤å¡ç‰Œ
                setTimeout(() => {
                    // éªŒè¯ç´¢å¼•ä»ç„¶æœ‰æ•ˆï¼Œé˜²æ­¢ç«æ€æ¡ä»¶å¯¼è‡´çš„é”™è¯¯
                    const validIndices = [index1, index2, index3].filter(index => 
                        index >= 0 && index < this.slots.length && this.slots[index] && this.slots[index].emoji === emoji
                    );
                    
                    if (validIndices.length !== 3) {
                        console.error(`é”™è¯¯ï¼šé¢„æœŸç§»é™¤3å¼ ${emoji}ï¼Œä½†åªæ‰¾åˆ°${validIndices.length}å¼ æœ‰æ•ˆå¡ç‰Œ`);
                        console.error(`åŸå§‹ç´¢å¼•: [${index1}, ${index2}, ${index3}]`);
                        console.error(`æœ‰æ•ˆç´¢å¼•: [${validIndices.join(', ')}]`);
                        console.error(`å½“å‰æ§½ä½çŠ¶æ€: [${this.slots.map((c, idx) => `${idx}:${c.emoji}`).join(', ')}]`);
                        this.isRemoving = false; // é‡ç½®æ ‡å¿—
                        return;
                    }
                    
                    // å°†æœ‰æ•ˆç´¢å¼•æ’åºï¼Œä»å¤§åˆ°å°ç§»é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–å½±å“
                    const sortedIndices = validIndices.sort((a, b) => b - a);
                    console.log(`ç§»é™¤æ§½ä½å¡ç‰Œ: ${emoji} at indices [${index1}, ${index2}, ${index3}] -> valid sorted [${sortedIndices.join(', ')}]`);
                    
                    // æŒ‰é™åºç§»é™¤ï¼Œç¡®ä¿ç´¢å¼•ä¸ä¼šå› ä¸ºå‰é¢çš„ç§»é™¤è€Œæ”¹å˜
                    sortedIndices.forEach(index => {
                        console.log(`ç§»é™¤æ§½ä½ç´¢å¼• ${index}: ${this.slots[index]?.emoji}`);
                        this.slots.splice(index, 1);
                    });
                    
                    // é‡æ–°æ›´æ–°æ§½ä½æ˜¾ç¤º
                    this.updateSlotDisplay();
                    
                    console.log(`æ§½ä½æ¶ˆé™¤åçŠ¶æ€: [${this.slots.map((c, idx) => `${idx}:${c.emoji}`).join(', ')}]`);
                    console.log(`æ¶ˆé™¤å®Œæˆï¼Œå‰©ä½™æ§½ä½æ•°: ${this.slots.length}`);
                    
                    // æ¸…é™¤ç§»é™¤æ ‡å¿—
                    this.isRemoving = false;
                    console.log(`ç§»é™¤æµç¨‹å®Œæˆï¼Œè®¾ç½®isRemoving=false`);
                    
                    // ç§»é™¤å®Œæˆåï¼Œå†æ¬¡æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„åŒ¹é…ï¼ˆé€’å½’è°ƒç”¨ï¼‰
                    this.checkSlotMatch();
                    
                    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                    this.checkGameEnd();
                }, 500);
            }

            gameOver(isLoss) {
                // ç¦ç”¨æ‰€æœ‰å¡ç‰Œçš„ç‚¹å‡»
                this.cards.forEach(card => {
                    card.isClickable = false;
                });
                this.draw();

                if (isLoss) {
                    this.showModal('æ¸¸æˆå¤±è´¥', `åˆ«ç°å¿ƒï¼Œåœ¨ç¬¬${this.currentLevel}å…³å†è¯•ä¸€æ¬¡ï¼`, false, false);
                }
            }

            checkGameEnd() {
                const visibleCards = this.cards.filter(card => card.visible);
                const clickableCards = visibleCards.filter(card => card.isClickable);

                // èƒœåˆ©æ¡ä»¶
                if (visibleCards.length === 0 && this.slots.length === 0) {
                    if (this.currentLevel < this.maxLevel) {
                        this.showModal(`ç¬¬${this.currentLevel}å…³èƒœåˆ©ï¼`, 'å¤ªæ£’äº†ï¼å‡†å¤‡æŒ‘æˆ˜ä¸‹ä¸€å…³å§ï¼', true, true);
                    } else {
                        this.showModal('æ­å–œé€šå…³ï¼', 'æ‚¨å·²å®Œæˆæ‰€æœ‰å…³å¡ï¼ŒçœŸå‰å®³ï¼', false, true);
                    }
                    this.gameOver(false); // æ¸¸æˆç»“æŸä½†éå¤±è´¥
                    return;
                }

                // å¤±è´¥æ¡ä»¶ï¼šæ²¡æœ‰å¯ç‚¹å‡»çš„å¡ç‰Œï¼Œå¹¶ä¸”æ§½é‡Œä¹Ÿæ²¡æœ‰å¯åˆæˆçš„
                if (clickableCards.length === 0 && this.slots.length > 0) {
                    const hasPotentialMatch = this.canMakeAnyMove();
                    if (!hasPotentialMatch) {
                        this.gameOver(true); // æ¸¸æˆå¤±è´¥
                    }
                }
            }

            // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä»»ä½•å¯è¡Œçš„ç§»åŠ¨ï¼ˆåŒ…æ‹¬ç‚¹å‡»æ–°å¡ç‰Œå½¢æˆé…å¯¹ï¼‰
            canMakeAnyMove() {
                const clickableCards = this.cards.filter(card => card.visible && card.isClickable);
                const slotCounts = {};
                this.slots.forEach(card => {
                    slotCounts[card.emoji] = (slotCounts[card.emoji] || 0) + 1;
                });

                // æ£€æŸ¥æ˜¯å¦æœ‰ç›´æ¥å¯ä»¥ä¸‰è¿çš„
                for (const emoji in slotCounts) {
                    if (slotCounts[emoji] >= 3) return true; // è™½ç„¶checkSlotMatchä¼šå¤„ç†ï¼Œä½†è¿™é‡Œä¹Ÿåˆ¤æ–­
                }

                // æ£€æŸ¥ç‚¹å‡»ä»»ä½•ä¸€ä¸ªå¯ç‚¹å‡»çš„å¡ç‰Œåï¼Œæ˜¯å¦èƒ½å½¢æˆä¸‰è¿
                for (const card of clickableCards) {
                    if ((slotCounts[card.emoji] || 0) === 2) {
                        return true; // ç‚¹å‡»è¿™å¼ ç‰Œå¯ä»¥å‡‘æˆä¸‰è¿
                    }
                }

                // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰è¶³å¤Ÿçš„ç©ºæ§½ä½å’Œå¡ç‰Œæ¥å®Œæˆæ¸¸æˆ
                if (this.slots.length + clickableCards.length < 3) {
                     // å¦‚æœæ§½ä½åŠ ä¸Šæ‰€æœ‰å¯ç‚¹å‡»çš„ç‰Œéƒ½å‡‘ä¸å¤Ÿ3ä¸ªï¼Œé‚£è‚¯å®šè¾“äº†
                     if (this.cards.filter(c => c.visible).length > 0) return false;
                }

                return false;
            }

            hasSlotMatch() {
                // æ£€æŸ¥æ§½ä½ä¸­æ˜¯å¦æœ‰å¯æ¶ˆé™¤çš„3å¼ ç›¸åŒå¡ç‰Œ
                for (let i = 0; i <= this.slots.length - 3; i++) {
                    if (this.slots[i].emoji === this.slots[i + 1].emoji && 
                        this.slots[i].emoji === this.slots[i + 2].emoji) {
                        return true;
                    }
                }
                return false;
            }

            draw() {
                // ä½¿ç”¨æ˜¾ç¤ºå°ºå¯¸æ¥æ¸…é™¤canvasï¼ˆåæ ‡ç³»ç»ŸåŸºäºæ˜¾ç¤ºå°ºå¯¸ï¼‰
                this.ctx.clearRect(0, 0, this.canvasDisplayWidth, this.canvasDisplayHeight);
                
                // ç»˜åˆ¶æ‰€æœ‰å¯è§å¡ç‰Œ
                this.cards.forEach(card => {
                    if (card.visible) {
                        card.draw(this.ctx);
                    }
                });
            }

            // é‡æ–°å¼€å§‹æ¸¸æˆ
            restart() {
                // é‡ç½®åˆ°ç¬¬ä¸€å…³
                this.currentLevel = 1;
                document.getElementById('modalNextLevelBtn').style.display = 'none';
                
                // æ¸…ç©ºæ¸¸æˆçŠ¶æ€
                this.cards = [];
                this.slots = [];
                this.isRemoving = false; // é‡ç½®ç§»é™¤æ ‡å¿—
                
                // æ¸…ç©ºæ§½ä½æ˜¾ç¤º
                this.initSlots();
                
                // é‡æ–°åˆå§‹åŒ–æ¸¸æˆ
                this.init();
            }

            // ç”Ÿæˆç¡®ä¿å¯æ¶ˆé™¤çš„å¡ç‰Œæ•°ç»„ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
            generateSolvableCards(totalCards, availableEmojis, levelConfig) {
                console.log('=== å¼€å§‹ç”Ÿæˆå¯æ¶ˆé™¤çš„å¡ç‰Œæ•°ç»„ ===');
                
                // ç¡®ä¿æ€»å¡ç‰Œæ•°æ˜¯3çš„å€æ•°
                const adjustedTotalCards = Math.floor(totalCards / 3) * 3;
                const totalGroups = adjustedTotalCards / 3;
                
                console.log(`åŸå§‹å¡ç‰Œæ•°: ${totalCards}, è°ƒæ•´å: ${adjustedTotalCards}, éœ€è¦ç”Ÿæˆ${totalGroups}ç»„`);
                
                // é™åˆ¶emojiç§ç±»æ•°é‡ï¼Œç¡®ä¿å®‰å…¨
                const maxEmojiTypes = Math.min(levelConfig.emojiTypes, availableEmojis.length, 8);
                const safeEmojis = availableEmojis.slice(0, maxEmojiTypes);
                
                console.log(`ä½¿ç”¨${safeEmojis.length}ç§emoji: ${safeEmojis.join(', ')}`);
                
                // ç¡®ä¿è‡³å°‘æœ‰è¶³å¤Ÿçš„emojiç§ç±»æ¥åˆ†é…æ‰€æœ‰ç»„
                if (totalGroups < safeEmojis.length) {
                    // å¦‚æœç»„æ•°å°‘äºemojiç§ç±»ï¼Œåˆ™åªä½¿ç”¨å‰totalGroupsç§emoji
                    const usedEmojis = safeEmojis.slice(0, totalGroups);
                    console.log(`ç»„æ•°è¾ƒå°‘ï¼Œåªä½¿ç”¨${usedEmojis.length}ç§emoji`);
                
                const cardEmojis = [];
                    usedEmojis.forEach(emoji => {
                        // æ¯ç§emojiä¸€ç»„ï¼ˆ3å¼ ï¼‰
                        for (let i = 0; i < 3; i++) {
                            cardEmojis.push(emoji);
                        }
                    });
                    
                    // éªŒè¯å¹¶è¿”å›
                    const validationResult = this.validateEmojiArray(cardEmojis);
                    if (validationResult.isValid) {
                        console.log('âœ… ç®€å•åˆ†é…æˆåŠŸç”Ÿæˆæœ‰æ•ˆå¡ç‰Œæ•°ç»„');
                        return this.shuffleArray(cardEmojis, levelConfig.shuffleRate);
                    }
                }
                
                // æ­£å¸¸æƒ…å†µï¼šå¹³å‡åˆ†é…ç»„æ•°åˆ°æ¯ç§emoji
                const cardEmojis = [];
                const groupsPerEmoji = Math.floor(totalGroups / safeEmojis.length);
                const remainingGroups = totalGroups % safeEmojis.length;
                
                console.log(`æ¯ç§emojiåŸºç¡€ç»„æ•°: ${groupsPerEmoji}, å‰©ä½™ç»„æ•°: ${remainingGroups}`);
                
                safeEmojis.forEach((emoji, index) => {
                    // å‰remainingGroupsç§emojiå¤šåˆ†é…ä¸€ç»„
                    const groupsForThisEmoji = groupsPerEmoji + (index < remainingGroups ? 1 : 0);
                    const cardsForThisEmoji = groupsForThisEmoji * 3;
                    
                    console.log(`${emoji}: ${groupsForThisEmoji}ç»„ (${cardsForThisEmoji}å¼ )`);
                    
                    // ä¸ºè¿™ç§emojiæ·»åŠ æ‰€æœ‰å¡ç‰Œ
                    for (let i = 0; i < cardsForThisEmoji; i++) {
                            cardEmojis.push(emoji);
                        }
                });
                
                // éªŒè¯ç”Ÿæˆçš„æ•°ç»„
                console.log(`ç”Ÿæˆäº†${cardEmojis.length}å¼ å¡ç‰Œï¼Œé¢„æœŸ${adjustedTotalCards}å¼ `);
                
                if (cardEmojis.length !== adjustedTotalCards) {
                    console.error(`ä¸¥é‡é”™è¯¯: ç”Ÿæˆçš„å¡ç‰Œæ•°é‡ä¸åŒ¹é…!`);
                    return this.generateEmergencyCards(adjustedTotalCards, safeEmojis);
                }
                
                // æœ€ç»ˆéªŒè¯
                const validationResult = this.validateEmojiArray(cardEmojis);
                if (!validationResult.isValid) {
                    console.error('ç”Ÿæˆçš„å¡ç‰Œæ•°ç»„éªŒè¯å¤±è´¥:', validationResult.errors);
                    return this.generateEmergencyCards(adjustedTotalCards, safeEmojis);
                }
                
                console.log('âœ… æˆåŠŸç”Ÿæˆæœ‰æ•ˆçš„å¡ç‰Œæ•°ç»„');
                console.log('éªŒè¯ç»“æœ:', validationResult);
                
                // æ ¹æ®å…³å¡éš¾åº¦æ‰“ä¹±æ•°ç»„
                return this.shuffleArray(cardEmojis, levelConfig.shuffleRate);
                }
                
            // éªŒè¯emojiæ•°ç»„çš„æœ‰æ•ˆæ€§
            validateEmojiArray(emojiArray) {
                const emojiCounts = {};
                emojiArray.forEach(emoji => {
                    emojiCounts[emoji] = (emojiCounts[emoji] || 0) + 1;
                });
                
                const errors = [];
                let validGroups = 0;
                
                Object.entries(emojiCounts).forEach(([emoji, count]) => {
                    if (count % 3 !== 0) {
                        errors.push(`${emoji}: ${count}å¼  (ä½™æ•°${count % 3})`);
                    } else {
                        validGroups += count / 3;
                    }
                });
                
                return {
                    isValid: errors.length === 0,
                    errors,
                    totalCards: emojiArray.length,
                    totalEmojis: Object.keys(emojiCounts).length,
                    validGroups,
                    emojiCounts
                };
            }

            // æ™ºèƒ½æ‰“ä¹±æ•°ç»„
            shuffleArray(array, shuffleRate) {
                const shuffledArray = [...array];
                const shuffleIterations = Math.max(1, Math.floor(array.length * shuffleRate));
                
                console.log(`æ‰“ä¹±${shuffleIterations}æ¬¡`);
                
                for (let iter = 0; iter < shuffleIterations; iter++) {
                    for (let i = shuffledArray.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
                    }
                }
                
                return shuffledArray;
            }

            // ç”Ÿæˆç»å¯¹å®‰å…¨çš„å¡ç‰Œæ•°ç»„ï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰
            generateSafeCards(totalCards, availableEmojis) {
                const cardEmojis = [];
                const groupsNeeded = Math.floor(totalCards / 3);
                
                // ä½¿ç”¨å¾ªç¯åˆ†é…ï¼Œç¡®ä¿æ¯ç§emojiéƒ½æœ‰å®Œæ•´çš„3å€æ•°ç»„
                for (let i = 0; i < groupsNeeded; i++) {
                    const emoji = availableEmojis[i % availableEmojis.length];
                    for (let j = 0; j < 3; j++) {
                        cardEmojis.push(emoji);
                    }
                }
                
                // æ‰“ä¹±æ•°ç»„
                for (let i = cardEmojis.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [cardEmojis[i], cardEmojis[j]] = [cardEmojis[j], cardEmojis[i]];
                }
                
                return cardEmojis;
            }

            // ç´§æ€¥å¤‡ç”¨æ–¹æ¡ˆï¼šæœ€ç®€å•çš„ç”Ÿæˆæ–¹æ³•ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
            generateEmergencyCards(totalCards, availableEmojis) {
                console.log('=== ä½¿ç”¨ç´§æ€¥å¤‡ç”¨æ–¹æ¡ˆç”Ÿæˆå¡ç‰Œ ===');
                
                const adjustedTotalCards = Math.floor(totalCards / 3) * 3;
                const groupsNeeded = adjustedTotalCards / 3;
                
                // åªä½¿ç”¨å‰6ç§emojiï¼Œç¡®ä¿ç»å¯¹å®‰å…¨
                const safeEmojis = availableEmojis.slice(0, Math.min(6, availableEmojis.length));
                
                console.log(`ç´§æ€¥æ–¹æ¡ˆ: ç”Ÿæˆ${groupsNeeded}ç»„å¡ç‰Œï¼Œä½¿ç”¨${safeEmojis.length}ç§emoji`);
                console.log('ä½¿ç”¨çš„emoji:', safeEmojis);
                
                const cardEmojis = [];
                
                // ç®€å•å¾ªç¯åˆ†é…ï¼šæ¯ç§emojiè½®æµåˆ†é…ï¼Œç›´åˆ°è¾¾åˆ°æ‰€éœ€ç»„æ•°
                for (let group = 0; group < groupsNeeded; group++) {
                    const emoji = safeEmojis[group % safeEmojis.length];
                    // ä¸ºå½“å‰ç»„æ·»åŠ 3å¼ ç›¸åŒçš„emoji
                    for (let i = 0; i < 3; i++) {
                            cardEmojis.push(emoji);
                        }
                    }
                
                console.log(`ç´§æ€¥æ–¹æ¡ˆç”Ÿæˆäº†${cardEmojis.length}å¼ å¡ç‰Œ`);
                
                // éªŒè¯ç”Ÿæˆçš„æ•°ç»„
                const validationResult = this.validateEmojiArray(cardEmojis);
                console.log('ç´§æ€¥æ–¹æ¡ˆéªŒè¯ç»“æœ:', validationResult);
                
                if (validationResult.isValid) {
                    console.log('âœ… ç´§æ€¥å¤‡ç”¨æ–¹æ¡ˆæˆåŠŸç”Ÿæˆæœ‰æ•ˆå¡ç‰Œæ•°ç»„');
                    // è½»åº¦æ‰“ä¹±ï¼Œé¿å…è¿‡äºè§„å¾‹
                    return this.shuffleArray(cardEmojis, 0.3);
                } else {
                    console.error('âŒ ç´§æ€¥å¤‡ç”¨æ–¹æ¡ˆéªŒè¯å¤±è´¥!', validationResult.errors);
                    // å¦‚æœè¿ç´§æ€¥æ–¹æ¡ˆéƒ½å¤±è´¥ï¼Œç”Ÿæˆæœ€åŸºç¡€çš„å¡ç‰Œ
                    return this.generateBasicCards(adjustedTotalCards, safeEmojis);
                }
            }

            // æœ€åŸºç¡€çš„å¡ç‰Œç”Ÿæˆï¼ˆæœ€åçš„ä¿é™©ï¼‰
            generateBasicCards(totalCards, availableEmojis) {
                console.log('=== ä½¿ç”¨æœ€åŸºç¡€çš„å¡ç‰Œç”Ÿæˆæ–¹æ³• ===');
                
                const cardEmojis = [];
                const emoji = availableEmojis[0]; // åªä½¿ç”¨ç¬¬ä¸€ç§emoji
                
                // ç”ŸæˆtotalCardså¼ ç›¸åŒçš„emojiå¡ç‰Œ
                for (let i = 0; i < totalCards; i++) {
                    cardEmojis.push(emoji);
                }
                
                console.log(`åŸºç¡€æ–¹æ¡ˆ: ç”Ÿæˆ${totalCards}å¼ ${emoji}å¡ç‰Œ`);
                
                // éªŒè¯
                const validationResult = this.validateEmojiArray(cardEmojis);
                if (validationResult.isValid) {
                    console.log('âœ… åŸºç¡€æ–¹æ¡ˆéªŒè¯æˆåŠŸ');
                } else {
                    console.error('âŒ è¿åŸºç¡€æ–¹æ¡ˆéƒ½å¤±è´¥äº†!', validationResult.errors);
                }
                
                return cardEmojis;
            }

            // åŠ¨æ€ä¿®å¤emojiæ•°é‡ï¼Œç¡®ä¿æ‰€æœ‰éƒ½æ˜¯3çš„å€æ•°
            fixEmojiCounts(cardEmojis, availableEmojis) {
                console.log('=== å¼€å§‹åŠ¨æ€ä¿®å¤emojiæ•°é‡ ===');
                
                // ç»Ÿè®¡å½“å‰æ¯ç§emojiçš„æ•°é‡
                const emojiCounts = {};
                cardEmojis.forEach(emoji => {
                    emojiCounts[emoji] = (emojiCounts[emoji] || 0) + 1;
                });
                
                console.log('ä¿®å¤å‰çš„emojiæ•°é‡:', emojiCounts);
                
                // è®¡ç®—éœ€è¦è¡¥å……çš„å¡ç‰Œ
                const cardsToAdd = [];
                let totalAdded = 0;
                
                Object.entries(emojiCounts).forEach(([emoji, count]) => {
                    const remainder = count % 3;
                    if (remainder !== 0) {
                        const needed = (3 - remainder) % 3; // éœ€è¦è¡¥å……çš„æ•°é‡
                        console.log(`${emoji}: å½“å‰${count}å¼ ï¼Œä½™æ•°${remainder}ï¼Œéœ€è¦è¡¥å……${needed}å¼ `);
                        
                        for (let i = 0; i < needed; i++) {
                            cardsToAdd.push(emoji);
                        }
                        totalAdded += needed;
                    }
                });
                
                if (totalAdded === 0) {
                    console.log('âœ… æ‰€æœ‰emojiæ•°é‡éƒ½æ˜¯3çš„å€æ•°ï¼Œæ— éœ€ä¿®å¤');
                    return cardEmojis;
                }
                
                console.log(`æ€»å…±éœ€è¦è¡¥å……${totalAdded}å¼ å¡ç‰Œ`);
                
                // å°†è¡¥å……çš„å¡ç‰Œæ·»åŠ åˆ°æ•°ç»„ä¸­
                const fixedCardEmojis = [...cardEmojis, ...cardsToAdd];
                
                // éªŒè¯ä¿®å¤ç»“æœ
                const fixedCounts = {};
                fixedCardEmojis.forEach(emoji => {
                    fixedCounts[emoji] = (fixedCounts[emoji] || 0) + 1;
                });
                
                console.log('ä¿®å¤åçš„emojiæ•°é‡:', fixedCounts);
                
                // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨ä¿®å¤æˆåŠŸ
                let allValid = true;
                Object.entries(fixedCounts).forEach(([emoji, count]) => {
                    if (count % 3 !== 0) {
                        allValid = false;
                        console.error(`âŒ ä¿®å¤å¤±è´¥: ${emoji}ä»æœ‰${count}å¼ ï¼Œä¸æ˜¯3çš„å€æ•°`);
                    } else {
                        console.log(`âœ… ä¿®å¤æˆåŠŸ: ${emoji}ç°åœ¨æœ‰${count}å¼ `);
                    }
                });
                
                if (allValid) {
                    console.log(`âœ… åŠ¨æ€ä¿®å¤å®Œæˆï¼æ€»å…±è¡¥å……äº†${totalAdded}å¼ å¡ç‰Œ`);
                } else {
                    console.error('âŒ åŠ¨æ€ä¿®å¤å¤±è´¥ï¼');
                }
                
                return fixedCardEmojis;
            }

            // è°ƒè¯•æ£€æµ‹æ¸¸æˆçŠ¶æ€
            debugGameState() {
                console.log('=== æ¸¸æˆçŠ¶æ€è°ƒè¯•æ£€æµ‹ ===');
                console.log(`å½“å‰å…³å¡: ${this.currentLevel}`);
                console.log(`æ€»å¡ç‰Œæ•°: ${this.cards.length}`);
                console.log(`æ§½ä½å¡ç‰Œæ•°: ${this.slots.length}`);
                
                // è·å–å½“å‰æ¸¸æˆä¸­å®é™…å­˜åœ¨çš„å¡ç‰Œï¼šå¯è§çš„å¡ç‰Œ + æ§½ä½ä¸­çš„å¡ç‰Œ
                const visibleCards = this.cards.filter(card => card.visible);
                const allActiveCards = [...visibleCards, ...this.slots];
                console.log(`å¯è§å¡ç‰Œæ•°: ${visibleCards.length}`);
                console.log(`å‰©ä½™å¡ç‰Œæ€»æ•°: ${allActiveCards.length}`);
                
                // ç»Ÿè®¡æ¯ç§emojiçš„æ•°é‡ï¼ˆåªç»Ÿè®¡å½“å‰æ¸¸æˆä¸­å­˜åœ¨çš„ï¼‰
                const emojiCounts = {};
                allActiveCards.forEach(card => {
                    emojiCounts[card.emoji] = (emojiCounts[card.emoji] || 0) + 1;
                });
                
                console.log('=== Emojiæ•°é‡ç»Ÿè®¡ ===');
                Object.keys(emojiCounts).forEach(emoji => {
                    const count = emojiCounts[emoji];
                    const remainder = count % 3;
                    console.log(`${emoji}: ${count}å¼  (ä½™æ•°: ${remainder})`);
                });
                
                // æ£€æµ‹æ˜¯å¦æ‰€æœ‰emojiéƒ½èƒ½3-3é…å¯¹ç©·å°½
                const canComplete = this.checkGameCompletable(emojiCounts);
                console.log('=== é…å¯¹æ£€æµ‹ç»“æœ ===');
                console.log(`æ¸¸æˆæ˜¯å¦å¯å®Œæˆ: ${canComplete ? 'æ˜¯' : 'å¦'}`);
                
                if (!canComplete) {
                    console.log('âš ï¸  è­¦å‘Šï¼šæ¸¸æˆæ— æ³•å®Œæˆï¼å­˜åœ¨æ— æ³•é…å¯¹çš„emojiï¼');
                    this.analyzeProblematicEmojis(emojiCounts);
                } else {
                    console.log('âœ… æ¸¸æˆå¯ä»¥æ­£å¸¸å®Œæˆï¼Œæ‰€æœ‰emojiéƒ½å¯ä»¥3-3é…å¯¹ç©·å°½');
                }
                
                // è¯¦ç»†åˆ†æé…å¯¹å¯èƒ½æ€§
                this.analyzePairingPossibilities(emojiCounts);
                
                // æ˜¾ç¤ºæ§½ä½ä¸­çš„å¡ç‰Œ
                console.log('=== æ§½ä½çŠ¶æ€ ===');
                this.slots.forEach((card, index) => {
                    console.log(`æ§½ä½${index + 1}: ${card.emoji}`);
                });
                
                // æ˜¾ç¤ºå¯ç‚¹å‡»çš„å¡ç‰Œæ•°é‡å’Œè¯¦æƒ…
                const clickableCards = this.cards.filter(card => card.visible && card.isClickable);
                const blockedCards = this.cards.filter(card => card.visible && !card.isClickable);
                console.log(`å¯ç‚¹å‡»å¡ç‰Œæ•°: ${clickableCards.length}`);
                console.log(`è¢«é®æŒ¡å¡ç‰Œæ•°: ${blockedCards.length}`);
                
                // æ˜¾ç¤ºå‰©ä½™å¯ç‚¹å‡»å¡ç‰Œçš„è¯¦æƒ…
                if (clickableCards.length > 0) {
                    console.log('=== å‰©ä½™å¯ç‚¹å‡»å¡ç‰Œè¯¦æƒ… ===');
                    clickableCards.forEach((card, index) => {
                        console.log(`å¯ç‚¹å‡»å¡ç‰Œ${index + 1}: ${card.emoji} (å±‚çº§: ${card.layer}, ä½ç½®: ${Math.round(card.x)}, ${Math.round(card.y)})`);
                    });
                }
                
                // å¦‚æœæœ‰å‰©ä½™å¡ç‰Œä½†æ•°é‡ä¸æ˜¯3çš„å€æ•°ï¼Œæ˜¾ç¤ºè­¦å‘Š
                if (allActiveCards.length > 0 && !this.checkGameCompletable(emojiCounts)) {
                    console.log('âš ï¸  è­¦å‘Šï¼šå½“å‰å‰©ä½™å¡ç‰Œæ— æ³•å®Œæˆ3-3é…å¯¹ï¼');
                }
                
                console.log('=== æ£€æµ‹å®Œæˆ ===');
            }

            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦å¯å®Œæˆ
            checkGameCompletable(emojiCounts) {
                // æ£€æŸ¥æ¯ç§emojiçš„æ•°é‡æ˜¯å¦éƒ½æ˜¯3çš„å€æ•°
                for (const emoji in emojiCounts) {
                    const count = emojiCounts[emoji];
                    if (count % 3 !== 0) {
                        return false;
                    }
                }
                return true;
            }

            // åˆ†ææœ‰é—®é¢˜çš„emoji
            analyzeProblematicEmojis(emojiCounts) {
                console.log('=== é—®é¢˜Emojiåˆ†æ ===');
                Object.keys(emojiCounts).forEach(emoji => {
                    const count = emojiCounts[emoji];
                    const remainder = count % 3;
                    if (remainder !== 0) {
                        console.log(`é—®é¢˜emoji ${emoji}: ${count}å¼ , ä½™æ•°${remainder}`);
                        if (remainder === 1) {
                            console.log(`  -> éœ€è¦${3 - remainder}å¼ æ‰èƒ½é…å¯¹ï¼Œä½†åªæœ‰1å¼ ï¼Œæ— æ³•é…å¯¹`);
                        } else if (remainder === 2) {
                            console.log(`  -> éœ€è¦${3 - remainder}å¼ æ‰èƒ½é…å¯¹ï¼Œä½†åªæœ‰2å¼ ï¼Œæ— æ³•é…å¯¹`);
                        }
                    }
                });
            }

            // åˆ†æé…å¯¹å¯èƒ½æ€§
            analyzePairingPossibilities(emojiCounts) {
                console.log('=== é…å¯¹å¯èƒ½æ€§åˆ†æ ===');
                let totalPairs = 0;
                let remainingCards = 0;
                
                Object.keys(emojiCounts).forEach(emoji => {
                    const count = emojiCounts[emoji];
                    const pairs = Math.floor(count / 3);
                    const remainder = count % 3;
                    
                    console.log(`${emoji}: å¯ç»„æˆ${pairs}ç»„3å¼ é…å¯¹ï¼Œå‰©ä½™${remainder}å¼ `);
                    totalPairs += pairs;
                    remainingCards += remainder;
                });
                
                console.log(`æ€»è®¡å¯ç»„æˆ${totalPairs}ç»„3å¼ é…å¯¹`);
                console.log(`æ€»è®¡å‰©ä½™${remainingCards}å¼ æ— æ³•é…å¯¹`);
                
                if (remainingCards === 0) {
                    console.log('âœ… æ‰€æœ‰å¡ç‰Œéƒ½å¯ä»¥å®Œç¾é…å¯¹');
                } else {
                    console.log(`âŒ æœ‰${remainingCards}å¼ å¡ç‰Œæ— æ³•é…å¯¹`);
                }
            }

            // æ›´æ–°å…³å¡æ˜¾ç¤º
            updateLevelDisplay() {
                const levelConfig = this.levelConfigs[this.currentLevel - 1];
                document.getElementById('currentLevel').textContent = this.currentLevel;
                document.getElementById('difficulty').textContent = levelConfig.name;
            }

            // ä¸‹ä¸€å…³
            nextLevel() {
                if (this.currentLevel >= this.maxLevel) {
                    return;
                }

                this.currentLevel++;
                
                // æ¸…ç©ºæ¸¸æˆçŠ¶æ€
                this.cards = [];
                this.slots = [];
                this.isRemoving = false; // é‡ç½®ç§»é™¤æ ‡å¿—
                
                // æ¸…ç©ºæ§½ä½æ˜¾ç¤º
                this.initSlots();
                
                // é‡æ–°åˆå§‹åŒ–æ¸¸æˆ
                this.init();

            }

            showModal(title, message, showNextLevelButton, isWin) {
                const modal = document.getElementById('modal');
                document.getElementById('modalTitle').textContent = title;
                document.getElementById('modalMessage').textContent = message;

                const modalNextLevelBtn = document.getElementById('modalNextLevelBtn');
                const modalRestartBtn = document.getElementById('modalRestartBtn');

                if (showNextLevelButton) {
                    modalNextLevelBtn.style.display = 'inline-block';
                    modalRestartBtn.style.display = 'none';
                } else {
                    modalNextLevelBtn.style.display = 'none';
                    modalRestartBtn.style.display = 'inline-block';
                }
                
                if (isWin && this.currentLevel >= this.maxLevel) {
                    modalNextLevelBtn.style.display = 'none';
                    modalRestartBtn.style.display = 'inline-block';
                }

                modal.style.display = 'flex';

                if (!this.modalListenersAdded) {
                    modalNextLevelBtn.onclick = () => {
                        this.hideModal();
                        this.nextLevel();
                    };
                    modalRestartBtn.onclick = () => {
                        this.hideModal();
                        this.restart();
                    };
                    this.modalListenersAdded = true;
                }
            }

            hideModal() {
                document.getElementById('modal').style.display = 'none';
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        window.addEventListener('load', () => {
            const canvas = document.getElementById('gameCanvas');
            window.game = new Game(canvas);
        });
    </script>
</body>
</html>