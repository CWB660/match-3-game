<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¾Šäº†ä¸ªç¾Š - ç®€å•ç‰ˆæœ¬</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #333;
            background: white;
            cursor: pointer;
        }
        .info {
            margin: 10px 0;
            font-size: 18px;
        }
        .selected-cards {
            margin: 10px 0;
            display: flex;
            gap: 10px;
        }
        .card-slot {
            width: 50px;
            height: 50px;
            border: 2px dashed #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            background: #f9f9f9;
        }
        .card-slot.filled {
            border: 2px solid #4CAF50;
            background: #e8f5e8;
        }
        .slot-container {
            margin: 20px 0;
            text-align: center;
        }
        .slots {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
            min-height: 60px;
            background: #f5f5f5;
            border-radius: 8px;
            padding: 10px;
        }
        .slot-card {
            width: 65px;
            height: 65px;
            border: 2px solid #81C784;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            background: #81C784;
            color: white;
            transition: all 0.3s ease;
            position: relative;
        }
        .slot-card.removing {
            animation: slotRemove 0.5s ease-out;
        }
        @keyframes slotRemove {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); background: #A5D6A7; }
            100% { transform: scale(0); opacity: 0; }
        }
        .slot-card.adding {
            animation: slotAdd 0.5s ease-out;
        }
        @keyframes slotAdd {
            0% { transform: scale(0) translateY(-50px); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
        .slot-card.warning {
            border-color: #FF5722;
            background: #FFCDD2;
            color: #B71C1C;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        .controls button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        #restartBtn {
            background: #FF5722;
            color: white;
        }
        #restartBtn:hover {
            background: #E64A19;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #saveBtn {
            background: #4CAF50;
            color: white;
        }
        #saveBtn:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #nextLevelBtn {
            background: #2196F3;
            color: white;
        }
        #nextLevelBtn:hover {
            background: #1976D2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #debugBtn {
            background: #9C27B0;
            color: white;
        }
        #debugBtn:hover {
            background: #7B1FA2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .level-info {
            margin: 15px 0;
            display: flex;
            gap: 30px;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
        }
        .level-info .info {
            background: #E3F2FD;
            padding: 8px 16px;
            border-radius: 20px;
            border: 2px solid #2196F3;
            color: #1976D2;
        }
        .emoji-count {
            margin: 10px 0;
            padding: 10px;
            background: #F5F5F5;
            border-radius: 8px;
            font-size: 14px;
            max-height: 60px;
            overflow-y: auto;
        }
        .emoji-count-item {
            display: inline-block;
            margin: 2px 5px;
            padding: 2px 6px;
            background: #E8F5E8;
            border-radius: 10px;
            font-size: 12px;
        }
        .emoji-count-item.warning {
            background: #FFF3E0;
            color: #E65100;
        }
        .emoji-count-item.danger {
            background: #FFEBEE;
            color: #C62828;
        }
    </style>
</head>
<body>
    <h1>ç¾Šäº†ä¸ªç¾Š</h1>
    <div class="info">ç‚¹å‡»å¡ç‰Œå³å¯æ¶ˆé™¤ï¼Œåªæœ‰æœªè¢«é®æŒ¡çš„å¡ç‰Œå¯ä»¥ç‚¹å‡»</div>
    <canvas id="gameCanvas" width="1200" height="800"></canvas>
    
    <!-- 8æ§½ä½åˆ—è¡¨ -->
    <div class="slot-container">
        <div class="info">æ§½ä½åˆ—è¡¨ (æœ€å¤š8å¼ )</div>
        <div class="slots" id="slotContainer">
            <!-- æ§½ä½å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>
    
    <div class="controls">
        <button id="restartBtn" onclick="game.restart()">é‡æ–°å¼€å§‹</button>
        <button id="saveBtn" onclick="game.saveGame()">ä¿å­˜è¿›åº¦</button>
        <button id="nextLevelBtn" onclick="game.nextLevel()" style="display: none;">ä¸‹ä¸€å…³</button>
        <button id="debugBtn" onclick="game.debugGameState()">è°ƒè¯•æ£€æµ‹</button>
    </div>
    
    <div class="level-info">
        <div class="info">ç¬¬ <span id="currentLevel">1</span> å…³</div>
        <div class="info">éš¾åº¦ï¼š<span id="difficulty">ç®€å•</span></div>
    </div>
    
    <div class="emoji-count" id="emojiCount">
        <!-- å¡ç‰Œæ•°é‡ç»Ÿè®¡å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
    </div>
    
    <div class="info" id="gameStatus">ç‚¹å‡»å¡ç‰Œå¼€å§‹æ¸¸æˆ</div>

    <script>
        class Card {
            constructor(x, y, layer, emoji) {
                this.x = x;
                this.y = y;
                this.width = 65;
                this.height = 65;
                this.layer = layer;
                this.emoji = emoji;
                this.visible = true;
                this.selected = false;
                this.isClickable = true;
                this.isBlocked = false;
            }

            draw(ctx) {
                if (!this.visible) return;

                ctx.save();
                
                // å¡ç‰Œé˜´å½±
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                // å¡ç‰ŒèƒŒæ™¯ï¼šç»Ÿä¸€æµ…é»„è‰²ï¼Œåªæœ‰è¢«é®æŒ¡çš„æ‰å˜æš—
                if (this.selected) {
                    ctx.fillStyle = '#E8F5E8'; // é€‰ä¸­çŠ¶æ€ï¼šæ·¡ç»¿è‰²
                } else if (this.isBlocked) {
                    ctx.fillStyle = '#A5D6A7'; // è¢«é®æŒ¡çŠ¶æ€ï¼šæ·¡ç»¿è‰²
                } else {
                    ctx.fillStyle = '#F8FFD1'; // æ­£å¸¸çŠ¶æ€ï¼šæµ…é»„è‰²
                }
                
                // ç»˜åˆ¶åœ†è§’çŸ©å½¢
                const cardRadius = 8;
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, cardRadius);
                ctx.fill();
                
                // å¡ç‰Œè¾¹æ¡†ï¼šç»Ÿä¸€æš—ç»¿è‰²è¾¹æ¡†
                if (this.selected) {
                    ctx.strokeStyle = '#1B5E20'; // é€‰ä¸­çŠ¶æ€ï¼šå¾ˆæš—çš„æ·±ç»¿è‰²è¾¹æ¡†
                    ctx.lineWidth = 3;
                    ctx.shadowColor = 'rgba(27, 94, 32, 0.5)';
                    ctx.shadowBlur = 6;
                } else if (this.isBlocked) {
                    ctx.strokeStyle = '#2E7D32'; // è¢«é®æŒ¡çŠ¶æ€ï¼šæš—ç»¿è‰²è¾¹æ¡†
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(46, 125, 50, 0.2)';
                    ctx.shadowBlur = 2;
                } else {
                    // æ­£å¸¸çŠ¶æ€ï¼šæ·±ç»¿è‰²è¾¹æ¡†
                    ctx.strokeStyle = '#1B5E20';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(27, 94, 32, 0.3)';
                    ctx.shadowBlur = 3;
                }
                
                // ç»˜åˆ¶åœ†è§’è¾¹æ¡†
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, cardRadius);
                ctx.stroke();
                
                // é‡ç½®é˜´å½±æ•ˆæœï¼Œé¿å…å½±å“åç»­ç»˜åˆ¶
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                // ç»˜åˆ¶emojiï¼šåªæœ‰è¢«é®æŒ¡çš„æ‰å˜æš—
                ctx.font = '32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                if (this.isBlocked) {
                    ctx.fillStyle = '#424242'; // è¢«é®æŒ¡çŠ¶æ€ï¼šå¾ˆæš—çš„ç°è‰²
                } else {
                    ctx.fillStyle = '#FFFFFF'; // æ­£å¸¸çŠ¶æ€ï¼šçº¯ç™½è‰²
                }
                ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height/2);

                // å±‚çº§æ ‡è¯†ï¼ˆè°ƒè¯•ç”¨ï¼‰
                ctx.font = '10px Arial';
                ctx.fillStyle = '#666';
                ctx.fillText(this.layer.toString(), this.x + 5, this.y + 10);

                // ä¸ºè¢«é®æŒ¡çš„å¡ç‰Œæ·»åŠ åŠé€æ˜è¦†ç›–å±‚ï¼Œå¢å¼ºæš—æ·¡æ•ˆæœ
                if (this.isBlocked) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.beginPath();
                    ctx.roundRect(this.x, this.y, this.width, this.height, cardRadius);
                    ctx.fill();
                }

                ctx.restore();
            }

  
            isPointInside(x, y) {
                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }
        }

        class Game {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.cards = [];
                this.slots = []; // æ§½ä½ä¸­çš„å¡ç‰Œ
                this.maxSlots = 8; // æœ€å¤š8ä¸ªæ§½ä½
                this.currentLevel = 1;
                this.maxLevel = 10;
                this.emojis = ['ğŸ‘', 'ğŸŒŸ', 'ğŸˆ', 'ğŸŒº', 'ğŸ', 'ğŸš€', 'ğŸŒˆ', 'ğŸ¯', 'ğŸ¦‹', 'ğŸŒ¸', 'ğŸŠ', 'ğŸ¦„', 'ğŸ±', 'ğŸ¶', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ¸'];
                
                // å…³å¡é…ç½®
                this.levelConfigs = [
                    { level: 1, name: 'ç®€å•', emojiTypes: 8, repetitionRate: 0.15, cardMultiplier: 0.8, shuffleRate: 0.2 },
                    { level: 2, name: 'ç®€å•', emojiTypes: 9, repetitionRate: 0.18, cardMultiplier: 0.85, shuffleRate: 0.3 },
                    { level: 3, name: 'æ™®é€š', emojiTypes: 10, repetitionRate: 0.22, cardMultiplier: 0.9, shuffleRate: 0.4 },
                    { level: 4, name: 'æ™®é€š', emojiTypes: 11, repetitionRate: 0.25, cardMultiplier: 0.95, shuffleRate: 0.5 },
                    { level: 5, name: 'æ™®é€š', emojiTypes: 12, repetitionRate: 0.28, cardMultiplier: 1.0, shuffleRate: 0.6 },
                    { level: 6, name: 'å›°éš¾', emojiTypes: 13, repetitionRate: 0.32, cardMultiplier: 1.05, shuffleRate: 0.7 },
                    { level: 7, name: 'å›°éš¾', emojiTypes: 14, repetitionRate: 0.35, cardMultiplier: 1.1, shuffleRate: 0.8 },
                    { level: 8, name: 'å›°éš¾', emojiTypes: 15, repetitionRate: 0.38, cardMultiplier: 1.15, shuffleRate: 0.85 },
                    { level: 9, name: 'ä¸“å®¶', emojiTypes: 16, repetitionRate: 0.42, cardMultiplier: 1.2, shuffleRate: 0.9 },
                    { level: 10, name: 'ä¸“å®¶', emojiTypes: 18, repetitionRate: 0.45, cardMultiplier: 1.25, shuffleRate: 0.95 }
                ];
                this.init();
                this.bindEvents();
                this.initSlots();
            }

            init() {
                this.updateLevelDisplay();
                this.createCards();
                this.updateClickableStatus();
                this.updateEmojiCountDisplay();
                this.draw();
            }

            initSlots() {
                const slotContainer = document.getElementById('slotContainer');
                slotContainer.innerHTML = '';
                for (let i = 0; i < this.maxSlots; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'slot-card';
                    slot.id = `slot-${i}`;
                    slotContainer.appendChild(slot);
                }
            }

            createCards() {
                // è·å–å½“å‰å…³å¡é…ç½®
                const levelConfig = this.levelConfigs[this.currentLevel - 1];
                
                // æ¯å±‚ä½¿ç”¨éšæœºæ•°é‡çš„å¡ç‰Œï¼ŒåŸºäºå…³å¡é…ç½®è°ƒæ•´
                let layerSizes = [];
                const baseMinCards = 20; // åŸºç¡€æ¯å±‚æœ€å°‘å¡ç‰Œæ•°
                const baseMaxCards = 40; // åŸºç¡€æ¯å±‚æœ€å¤šå¡ç‰Œæ•°
                
                for (let i = 0; i < 7; i++) {
                    // ç”Ÿæˆæ¯å±‚çš„éšæœºå¡ç‰Œæ•°é‡ï¼Œä¸­é—´å±‚æ¬¡å¤šä¸€äº›
                    let rangeMin, rangeMax;
                    if (i === 3) {
                        // ä¸­é—´å±‚ï¼ˆç¬¬3å±‚ï¼‰å¡ç‰Œæœ€å¤š
                        rangeMin = 35;
                        rangeMax = 45;
                    } else if (i === 2 || i === 4) {
                        // æ¬¡ä¸­é—´å±‚
                        rangeMin = 30;
                        rangeMax = 40;
                    } else if (i === 1 || i === 5) {
                        // è¾¹ç¼˜å±‚
                        rangeMin = 25;
                        rangeMax = 35;
                    } else {
                        // æœ€å¤–å±‚
                        rangeMin = baseMinCards;
                        rangeMax = 30;
                    }
                    
                    // æ ¹æ®å…³å¡è°ƒæ•´å¡ç‰Œæ•°é‡
                    rangeMin = Math.floor(rangeMin * levelConfig.cardMultiplier);
                    rangeMax = Math.floor(rangeMax * levelConfig.cardMultiplier);
                    
                    const randomCount = Math.floor(Math.random() * (rangeMax - rangeMin + 1)) + rangeMin;
                    layerSizes.push(randomCount);
                }
                
                let totalCards = layerSizes.reduce((sum, size) => sum + size, 0);
                
                // ç¡®ä¿æ€»å¡ç‰Œæ•°æ˜¯3çš„å€æ•°ï¼Œé¿å…åç»­ç”Ÿæˆé—®é¢˜
                totalCards = Math.floor(totalCards / 3) * 3;
                
                // æ ¹æ®å…³å¡é€‰æ‹©emojiç§ç±»
                const availableEmojis = this.emojis.slice(0, levelConfig.emojiTypes);
                
                // ç”Ÿæˆç¡®ä¿å¯æ¶ˆé™¤çš„å¡ç‰Œæ•°ç»„
                let cardEmojis = this.generateSolvableCards(totalCards, availableEmojis, levelConfig);
                
                // åŠ¨æ€ä¿®å¤ï¼šæ£€æµ‹å¹¶è¡¥å……ä¸æ»¡è¶³3å€æ•°çš„emoji
                cardEmojis = this.fixEmojiCounts(cardEmojis, availableEmojis);
                
                // æ›´æ–°æ€»å¡ç‰Œæ•°ï¼ˆå¯èƒ½è°ƒæ•´ä¸º3çš„å€æ•°ï¼‰
                totalCards = cardEmojis.length;
                
                // è°ƒæ•´layerSizesä»¥åŒ¹é…cardEmojisçš„é•¿åº¦
                const originalTotal = layerSizes.reduce((sum, size) => sum + size, 0);
                if (originalTotal !== totalCards) {
                    console.log(`è°ƒæ•´layerSizes: ${originalTotal} -> ${totalCards}`);
                    
                    // ä½¿ç”¨æ›´ç²¾ç¡®çš„åˆ†é…æ–¹æ³•ï¼Œç¡®ä¿ä¸ä¸¢å¤±ä»»ä½•å¡ç‰Œ
                    const newLayerSizes = [];
                    let remainingCards = totalCards;
                    
                    // æŒ‰æ¯”ä¾‹åˆ†é…ï¼Œç¡®ä¿æ€»å’Œç­‰äºtotalCards
                    for (let i = 0; i < layerSizes.length - 1; i++) {
                        // è®¡ç®—å½“å‰å±‚åº”è¯¥åˆ†é…çš„å¡ç‰Œæ•°ï¼ˆæŒ‰åŸæ¯”ä¾‹ï¼‰
                        const proportion = layerSizes[i] / originalTotal;
                        const allocatedCards = Math.floor(totalCards * proportion);
                        newLayerSizes.push(allocatedCards);
                        remainingCards -= allocatedCards;
                    }
                    
                    // æœ€åä¸€å±‚åˆ†é…æ‰€æœ‰å‰©ä½™çš„å¡ç‰Œï¼Œç¡®ä¿ä¸ä¸¢å¤±
                    newLayerSizes.push(remainingCards);
                    
                    layerSizes = newLayerSizes;
                    console.log('è°ƒæ•´åçš„layerSizes:', layerSizes);
                    console.log('éªŒè¯æ€»å’Œ:', layerSizes.reduce((sum, size) => sum + size, 0));
                    
                    // æœ€ç»ˆéªŒè¯ï¼šç¡®ä¿æ€»å’Œå®Œå…¨åŒ¹é…
                    const finalTotal = layerSizes.reduce((sum, size) => sum + size, 0);
                    if (finalTotal !== totalCards) {
                        console.error(`ä¸¥é‡é”™è¯¯ï¼šlayerSizesæ€»å’Œ(${finalTotal})ä»ä¸ç­‰äºtotalCards(${totalCards})`);
                        // å¼ºåˆ¶ä¿®æ­£ï¼šå°†å·®å€¼åŠ åˆ°æœ€åä¸€å±‚
                        const diff = totalCards - finalTotal;
                        layerSizes[layerSizes.length - 1] += diff;
                        console.log(`å¼ºåˆ¶ä¿®æ­£ï¼šç»™æœ€åä¸€å±‚æ·»åŠ ${diff}å¼ å¡ç‰Œ`);
                        console.log('æœ€ç»ˆlayerSizes:', layerSizes);
                    }
                }
                
                let emojiIndex = 0;
                
                // ä»é¡¶å±‚å¼€å§‹ç”Ÿæˆï¼ˆç¬¬6å±‚åˆ°ç¬¬0å±‚ï¼‰
                for (let layerIndex = layerSizes.length - 1; layerIndex >= 0; layerIndex--) {
                    const size = layerSizes[layerIndex];
                    console.log(`ç”Ÿæˆç¬¬${layerIndex}å±‚ï¼Œéœ€è¦${size}å¼ å¡ç‰Œ`);
                    
                    const positions = this.generateCompactPositions(size, layerIndex, layerSizes.length);
                    console.log(`ç¬¬${layerIndex}å±‚ç”Ÿæˆäº†${positions.length}ä¸ªä½ç½®`);
                    
                    if (positions.length !== size) {
                        console.error(`è­¦å‘Šï¼šç¬¬${layerIndex}å±‚ä½ç½®æ•°(${positions.length})ä¸éœ€æ±‚(${size})ä¸åŒ¹é…`);
                    }
                    
                    positions.forEach(pos => {
                        if (emojiIndex < cardEmojis.length) {
                            const emoji = cardEmojis[emojiIndex++];
                            this.cards.push(new Card(pos.x, pos.y, layerIndex, emoji));
                        } else {
                            console.error(`ä¸¥é‡é”™è¯¯ï¼šemojiIndex(${emojiIndex})è¶…å‡ºcardEmojisé•¿åº¦(${cardEmojis.length})`);
                        }
                    });
                }
                
                // éªŒè¯æ‰€æœ‰å¡ç‰Œéƒ½è¢«åˆ†é…
                console.log(`ç”Ÿæˆçš„å¡ç‰Œæ€»æ•°: ${this.cards.length}`);
                console.log(`é¢„æœŸå¡ç‰Œæ€»æ•°: ${totalCards}`);
                console.log(`ä½¿ç”¨çš„emojiæ•°é‡: ${emojiIndex}`);
                console.log(`å¯ç”¨emojiæ•°é‡: ${cardEmojis.length}`);
                
                if (this.cards.length !== totalCards) {
                    console.error(`ä¸¥é‡é”™è¯¯ï¼šå®é™…ç”Ÿæˆçš„å¡ç‰Œæ•°(${this.cards.length})ä¸ç­‰äºé¢„æœŸæ•°é‡(${totalCards})`);
                }
                
                if (emojiIndex !== cardEmojis.length) {
                    console.error(`ä¸¥é‡é”™è¯¯ï¼šä½¿ç”¨çš„emojiæ•°é‡(${emojiIndex})ä¸ç­‰äºå¯ç”¨æ•°é‡(${cardEmojis.length})`);
                }
                
                // ä¿æŒå±‚çº§æ’åºï¼ˆå…ˆç»˜åˆ¶ä½å±‚çº§ï¼‰
                this.cards.sort((a, b) => a.layer - b.layer);
            }
            
            generateCompactPositions(cardCount, layer, totalLayers) {
                const positions = [];
                const cardWidth = 65;
                const cardHeight = 65;
                const cardSpacing = 1; // æœ€å°é—´è·ï¼Œæ›´ç´§å‡‘
                
                // è®¡ç®—canvasä¸­å¿ƒç‚¹
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // æ ¹æ®å±‚çº§è®¡ç®—Yåæ ‡
                const layerSpacing = 55; // å‡å°‘å±‚çº§é—´è·ï¼Œæ›´ç´§å‡‘
                const yOffset = -160; // å‘ä¸Šåç§»ï¼Œè°ƒæ•´æ•´ä½“ä½ç½®ï¼ˆå¢åŠ å‘ä¸Šåç§»ï¼‰
                const yBase = centerY - (totalLayers - 1) * layerSpacing / 2 + layer * layerSpacing + yOffset;
                
                // è®¡ç®—æ¯è¡Œæœ€å¤šèƒ½æ”¾å¤šå°‘å¼ å¡ç‰Œï¼ˆç´§å‡‘å±…ä¸­æ’åˆ—ï¼‰
                const cardsPerRow = Math.min(cardCount, 11); // å¢åŠ æ¯è¡Œå¡ç‰Œæ•°
                const rows = Math.ceil(cardCount / cardsPerRow);
                
                // é€‚åº¦æ¨ªå‘å±‚çº§é”™å¼€æ•ˆæœ
                const horizontalOffset = cardWidth * (layer % 2 === 0 ? 0.8 : -0.8); // å¶æ•°å±‚å³ç§»ï¼Œå¥‡æ•°å±‚å·¦ç§»ï¼Œé”™å¼€0.8ä¸ªå¡ç‰Œå®½åº¦
                
                // ç¨å¾®å¢åŠ ç«–å‘å±‚çº§é”™å¼€æ•ˆæœ
                const verticalOffset = cardHeight * (layer % 3 === 0 ? 1.0 : layer % 3 === 1 ? -0.5 : 0.5); // 3å±‚ä¸€ä¸ªå¾ªç¯ï¼šç¬¬0å±‚ä¸‹ç§»ï¼Œç¬¬1å±‚ä¸Šç§»ï¼Œç¬¬2å±‚ä¸‹ç§»
                
                // æ ¹æ®å±‚çº§è°ƒæ•´æ¯è¡Œçš„å±…ä¸­ä½ç½®
                const layerWidthRatio = this.getLayerWidthRatio(layer, totalLayers);
                const adjustedCardsPerRow = Math.max(1, Math.floor(cardsPerRow * layerWidthRatio));
                
                let totalCardsPlaced = 0;
                for (let row = 0; row < rows; row++) {
                    const cardsInThisRow = Math.min(adjustedCardsPerRow, cardCount - totalCardsPlaced);
                    if (cardsInThisRow <= 0) break;
                    
                    const rowWidth = cardsInThisRow * (cardWidth + cardSpacing) - cardSpacing;
                    
                    // è®¡ç®—è¯¥è¡Œçš„èµ·å§‹Xåæ ‡ï¼ˆå±…ä¸­ + æ¨ªå‘å±‚çº§é”™å¼€ + å®½åº¦æ¯”ä¾‹è°ƒæ•´ï¼‰
                    const rowStartX = centerX - rowWidth / 2 + horizontalOffset;
                    
                    for (let col = 0; col < cardsInThisRow; col++) {
                        // ç´§å‡‘æ’åˆ—ï¼Œæœ€å°é—´è· + ç«–å‘å±‚çº§é”™å¼€
                        const x = rowStartX + col * (cardWidth + cardSpacing);
                        const y = yBase + row * (cardHeight + cardSpacing) + verticalOffset;
                        
                        positions.push({x, y});
                        totalCardsPlaced++;
                    }
                }
                
                // ç¡®ä¿ç”Ÿæˆäº†è¶³å¤Ÿçš„ä½ç½®
                if (positions.length !== cardCount) {
                    console.warn(`ç¬¬${layer}å±‚ï¼šéœ€è¦${cardCount}ä¸ªä½ç½®ï¼Œå®é™…ç”Ÿæˆ${positions.length}ä¸ªä½ç½®`);
                    
                    // å¦‚æœä½ç½®ä¸å¤Ÿï¼Œé‡æ–°è®¡ç®—æ›´åˆç†çš„å¸ƒå±€
                    const remaining = cardCount - positions.length;
                    console.log(`ç¬¬${layer}å±‚ï¼šéœ€è¦è¡¥å……${remaining}ä¸ªä½ç½®`);
                    
                    // é‡æ–°è®¡ç®—è¡Œæ•°å’Œæ¯è¡Œå¡ç‰Œæ•°ï¼Œç¡®ä¿å¸ƒå±€æ›´ç´§å‡‘
                    const newCardsPerRow = Math.min(cardCount, Math.ceil(Math.sqrt(cardCount * 1.5))); // é€‚ä¸­çš„æ¯è¡Œå¡ç‰Œæ•°
                    const newRows = Math.ceil(cardCount / newCardsPerRow);
                    
                    // æ¸…ç©ºåŸæœ‰ä½ç½®ï¼Œé‡æ–°ç”Ÿæˆæ›´åˆç†çš„å¸ƒå±€
                    positions.length = 0;
                    
                    for (let row = 0; row < newRows; row++) {
                        const cardsInThisRow = Math.min(newCardsPerRow, cardCount - row * newCardsPerRow);
                        const rowWidth = cardsInThisRow * (cardWidth + cardSpacing) - cardSpacing;
                        const rowStartX = centerX - rowWidth / 2 + horizontalOffset;
                        
                        for (let col = 0; col < cardsInThisRow; col++) {
                            const x = rowStartX + col * (cardWidth + cardSpacing);
                            const y = yBase + row * (cardHeight + cardSpacing) + verticalOffset;
                            positions.push({x, y});
                        }
                    }
                    
                    console.log(`ç¬¬${layer}å±‚ï¼šé‡æ–°å¸ƒå±€åå…±${positions.length}ä¸ªä½ç½®ï¼Œ${newRows}è¡Œï¼Œæ¯è¡Œæœ€å¤š${newCardsPerRow}å¼ `);
                }
                
                return positions;
            }
            
            getLayerWidthRatio(layer, totalLayers) {
                // åŒæ¼æ–—ç»“æ„çš„å®½åº¦æ¯”ä¾‹ (7å±‚)
                const ratios = [0.4, 0.6, 0.8, 1.0, 0.8, 0.6, 0.4]; // ä»åº•å±‚åˆ°é¡¶å±‚çš„å®½åº¦æ¯”ä¾‹
                return ratios[layer] || 1.0;
            }

            updateClickableStatus() {
                // é‡ç½®æ‰€æœ‰å¡ç‰Œçš„çŠ¶æ€
                this.cards.forEach(card => {
                    card.isClickable = false;
                    card.isBlocked = false;
                });

                // ä»é«˜å±‚åˆ°ä½å±‚æ£€æŸ¥é®æŒ¡å…³ç³»
                for (let i = this.cards.length - 1; i >= 0; i--) {
                    const card = this.cards[i];
                    if (!card.visible) continue;

                    let isBlocked = false;
                    
                    // æ£€æŸ¥æ˜¯å¦è¢«ä¸Šå±‚çš„å¡ç‰Œé®æŒ¡
                    for (let j = i + 1; j < this.cards.length; j++) {
                        const upperCard = this.cards[j];
                        if (!upperCard.visible) continue;
                        
                        if (this.isCardBlocked(card, upperCard)) {
                            isBlocked = true;
                            break;
                        }
                    }

                    // è®¾ç½®é®æŒ¡çŠ¶æ€å’Œç‚¹å‡»çŠ¶æ€
                    card.isBlocked = isBlocked;
                    if (!isBlocked) {
                        card.isClickable = true;
                    }
                }
            }

            isCardBlocked(lowerCard, upperCard) {
                // ç²¾ç¡®çš„åƒç´ çº§é®æŒ¡æ£€æµ‹ï¼šæ£€æŸ¥ä¸¤ä¸ªå¡ç‰Œæ˜¯å¦æœ‰é‡å åŒºåŸŸ
                const lowerLeft = lowerCard.x;
                const lowerRight = lowerCard.x + lowerCard.width;
                const lowerTop = lowerCard.y;
                const lowerBottom = lowerCard.y + lowerCard.height;
                
                const upperLeft = upperCard.x;
                const upperRight = upperCard.x + upperCard.width;
                const upperTop = upperCard.y;
                const upperBottom = upperCard.y + upperCard.height;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰é‡å 
                const horizontalOverlap = lowerLeft < upperRight && lowerRight > upperLeft;
                const verticalOverlap = lowerTop < upperBottom && lowerBottom > upperTop;
                
                // å¦‚æœæœ‰ä»»æ„é‡å ï¼Œåˆ™è®¤ä¸ºè¢«é®æŒ¡
                return horizontalOverlap && verticalOverlap;
            }

            bindEvents() {
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.handleClick(x, y);
                });
            }

            handleClick(x, y) {
                // ä»é«˜å±‚åˆ°ä½å±‚æŸ¥æ‰¾ç‚¹å‡»çš„å¡ç‰Œ
                for (let i = this.cards.length - 1; i >= 0; i--) {
                    const card = this.cards[i];
                    if (card.visible && card.isClickable && card.isPointInside(x, y)) {
                        this.removeCard(card);
                        break;
                    }
                }
            }

            removeCard(card) {
                if (this.slots.length >= this.maxSlots) {
                    document.getElementById('gameStatus').textContent = 'æ§½ä½å·²æ»¡ï¼æ¸¸æˆå¤±è´¥ï¼';
                    this.gameOver();
                    return;
                }

                // ä»æ¸¸æˆåŒºåŸŸç§»é™¤å¡ç‰Œ
                card.visible = false;
                
                // æ·»åŠ åˆ°æ§½ä½
                this.addToSlot(card);
                
                // æ›´æ–°æ‰€æœ‰å¡ç‰Œçš„å¯ç‚¹å‡»çŠ¶æ€
                this.updateClickableStatus();
                this.updateEmojiCountDisplay();
                this.draw();
                
                // è‡ªåŠ¨ä¿å­˜æ¸¸æˆè¿›åº¦
                this.autoSave();
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                this.checkGameEnd();
            }

            addToSlot(card) {
                // æŸ¥æ‰¾ç›¸åŒemojiçš„å¡ç‰Œåœ¨æ§½ä½ä¸­çš„ä½ç½®
                const sameEmojiIndex = this.slots.findIndex(slotCard => slotCard.emoji === card.emoji);
                
                if (sameEmojiIndex !== -1) {
                    // æ‰¾åˆ°ç›¸åŒemojiçš„å¡ç‰Œï¼Œæ’å…¥åˆ°å…¶æœ€åä¸€å¼ çš„å°¾éƒ¨
                    let insertIndex = sameEmojiIndex;
                    for (let i = sameEmojiIndex; i < this.slots.length; i++) {
                        if (this.slots[i].emoji === card.emoji) {
                            insertIndex = i + 1;
                        } else {
                            break;
                        }
                    }
                    this.slots.splice(insertIndex, 0, card);
                } else {
                    // æ²¡æœ‰æ‰¾åˆ°ç›¸åŒemojiçš„å¡ç‰Œï¼Œæ·»åŠ åˆ°æœ«å°¾
                    this.slots.push(card);
                }
                
                // æ›´æ–°æ§½ä½æ˜¾ç¤º
                this.updateSlotDisplay();
                
                // æ£€æŸ¥æ˜¯å¦æœ‰3å¼ ç›¸åŒçš„å¡ç‰Œ
                this.checkSlotMatch();
            }

            updateSlotDisplay() {
                const slotContainer = document.getElementById('slotContainer');
                const slotElements = slotContainer.children;
                
                // æ¸…ç©ºæ‰€æœ‰æ§½ä½
                for (let i = 0; i < slotElements.length; i++) {
                    const slot = slotElements[i];
                    slot.textContent = '';
                    slot.className = 'slot-card';
                }
                
                // å¡«å……æ§½ä½
                this.slots.forEach((card, index) => {
                    if (index < this.maxSlots) {
                        const slot = slotElements[index];
                        slot.textContent = card.emoji;
                        slot.className = 'slot-card adding';
                        
                        // æ·»åŠ å®ŒæˆåŠ¨ç”»åç§»é™¤åŠ¨ç”»ç±»
                        setTimeout(() => {
                            slot.classList.remove('adding');
                        }, 500);
                    }
                });
                
                // å¦‚æœæ§½ä½æ¥è¿‘æ»¡ï¼Œæ·»åŠ è­¦å‘Šæ•ˆæœ
                if (this.slots.length >= this.maxSlots - 1) {
                    for (let i = 0; i < slotElements.length; i++) {
                        if (i >= this.slots.length) {
                            slotElements[i].classList.add('warning');
                        }
                    }
                }
            }

            checkSlotMatch() {
                // æ£€æŸ¥æ˜¯å¦æœ‰3å¼ è¿ç»­çš„ç›¸åŒemoji
                for (let i = 0; i <= this.slots.length - 3; i++) {
                    if (this.slots[i].emoji === this.slots[i + 1].emoji && 
                        this.slots[i].emoji === this.slots[i + 2].emoji) {
                        this.removeSlotMatch(i, i + 1, i + 2);
                        return;
                    }
                }
            }

            removeSlotMatch(index1, index2, index3) {
                const emoji = this.slots[index1].emoji;
                
                // æ·»åŠ æ¶ˆé™¤åŠ¨ç”»
                const slotContainer = document.getElementById('slotContainer');
                const slotElements = slotContainer.children;
                
                [index1, index2, index3].forEach(index => {
                    if (slotElements[index]) {
                        slotElements[index].classList.add('removing');
                    }
                });
                
                // ç­‰å¾…åŠ¨ç”»å®Œæˆåç§»é™¤å¡ç‰Œ
                setTimeout(() => {
                    // ä»åå¾€å‰ç§»é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–
                    this.slots.splice(Math.max(index1, index2, index3), 1);
                    this.slots.splice(Math.max(index1, index2), 1);
                    this.slots.splice(Math.min(index1, index2), 1);
                    
                    document.getElementById('gameStatus').textContent = `æ¶ˆé™¤äº†3å¼  ${emoji}ï¼`;
                    
                    // é‡æ–°æ›´æ–°æ§½ä½æ˜¾ç¤º
                    this.updateSlotDisplay();
                    this.updateEmojiCountDisplay();
                    
                    // è‡ªåŠ¨ä¿å­˜æ¸¸æˆè¿›åº¦
                    this.autoSave();
                    
                    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                    this.checkGameEnd();
                }, 500);
            }

            gameOver() {
                // ç¦ç”¨æ‰€æœ‰å¡ç‰Œçš„ç‚¹å‡»
                this.cards.forEach(card => {
                    card.isClickable = false;
                });
                this.draw();
            }

            checkGameEnd() {
                const visibleCards = this.cards.filter(card => card.visible);
                const clickableCards = visibleCards.filter(card => card.isClickable);

                if (visibleCards.length === 0 && this.slots.length === 0) {
                    if (this.currentLevel < this.maxLevel) {
                        document.getElementById('gameStatus').textContent = `æ­å–œé€šè¿‡ç¬¬${this.currentLevel}å…³ï¼`;
                        document.getElementById('nextLevelBtn').style.display = 'inline-block';
                    } else {
                        document.getElementById('gameStatus').textContent = 'æ­å–œä½ ï¼å·²ç»é€šå…³æ‰€æœ‰å…³å¡ï¼';
                    }
                } else if (clickableCards.length === 0) {
                    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å¯æ¶ˆé™¤çš„æ§½ä½ç»„åˆ
                    const hasMatch = this.hasSlotMatch();
                    if (!hasMatch) {
                        document.getElementById('gameStatus').textContent = `ç¬¬${this.currentLevel}å…³å¤±è´¥ï¼Œå†è¯•ä¸€æ¬¡ï¼`;
                        this.gameOver();
                    }
                }
            }

            hasSlotMatch() {
                // æ£€æŸ¥æ§½ä½ä¸­æ˜¯å¦æœ‰å¯æ¶ˆé™¤çš„3å¼ ç›¸åŒå¡ç‰Œ
                for (let i = 0; i <= this.slots.length - 3; i++) {
                    if (this.slots[i].emoji === this.slots[i + 1].emoji && 
                        this.slots[i].emoji === this.slots[i + 2].emoji) {
                        return true;
                    }
                }
                return false;
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶æ‰€æœ‰å¯è§å¡ç‰Œ
                this.cards.forEach(card => {
                    if (card.visible) {
                        card.draw(this.ctx);
                    }
                });
            }

            // é‡æ–°å¼€å§‹æ¸¸æˆ
            restart() {
                // é‡ç½®åˆ°ç¬¬ä¸€å…³
                this.currentLevel = 1;
                document.getElementById('nextLevelBtn').style.display = 'none';
                
                // æ¸…ç©ºæ¸¸æˆçŠ¶æ€
                this.cards = [];
                this.slots = [];
                
                // æ¸…ç©ºæ§½ä½æ˜¾ç¤º
                this.initSlots();
                
                // é‡æ–°åˆå§‹åŒ–æ¸¸æˆ
                this.init();
                
                // é‡ç½®æ¸¸æˆçŠ¶æ€æ˜¾ç¤º
                document.getElementById('gameStatus').textContent = 'æ¸¸æˆå·²é‡æ–°å¼€å§‹ï¼';
                this.updateEmojiCountDisplay();
                
                // æ¸…é™¤ä¿å­˜çš„æ¸¸æˆè¿›åº¦
                localStorage.removeItem('ylgy_gameSave');
            }

            // ä¿å­˜æ¸¸æˆè¿›åº¦
            saveGame() {
                const gameData = {
                    currentLevel: this.currentLevel,
                    cards: this.cards.map(card => ({
                        x: card.x,
                        y: card.y,
                        width: card.width,
                        height: card.height,
                        layer: card.layer,
                        emoji: card.emoji,
                        visible: card.visible,
                        selected: card.selected,
                        isClickable: card.isClickable,
                        isBlocked: card.isBlocked
                    })),
                    slots: this.slots.map(card => ({
                        x: card.x,
                        y: card.y,
                        width: card.width,
                        height: card.height,
                        layer: card.layer,
                        emoji: card.emoji,
                        visible: card.visible,
                        selected: card.selected,
                        isClickable: card.isClickable,
                        isBlocked: card.isBlocked
                    })),
                    gameStatus: document.getElementById('gameStatus').textContent
                };
                
                localStorage.setItem('ylgy_gameSave', JSON.stringify(gameData));
                document.getElementById('gameStatus').textContent = 'æ¸¸æˆè¿›åº¦å·²ä¿å­˜ï¼';
                
                // 3ç§’åæ¢å¤åŸæ¥çš„æ¸¸æˆçŠ¶æ€
                setTimeout(() => {
                    document.getElementById('gameStatus').textContent = gameData.gameStatus;
                }, 3000);
            }

            // åŠ è½½æ¸¸æˆè¿›åº¦
            loadGame() {
                const savedData = localStorage.getItem('ylgy_gameSave');
                if (!savedData) {
                    return false;
                }
                
                try {
                    const gameData = JSON.parse(savedData);
                    
                    // æ¢å¤å…³å¡
                    this.currentLevel = gameData.currentLevel || 1;
                    this.updateLevelDisplay();
                    
                    // æ¸…ç©ºå½“å‰æ¸¸æˆçŠ¶æ€
                    this.cards = [];
                    this.slots = [];
                    
                    // æ¢å¤å¡ç‰Œæ•°æ®
                    gameData.cards.forEach(cardData => {
                        const card = new Card(cardData.x, cardData.y, cardData.layer, cardData.emoji);
                        card.visible = cardData.visible;
                        card.selected = cardData.selected;
                        card.isClickable = cardData.isClickable;
                        card.isBlocked = cardData.isBlocked;
                        this.cards.push(card);
                    });
                    
                    // æ¢å¤æ§½ä½æ•°æ®
                    gameData.slots.forEach(cardData => {
                        const card = new Card(cardData.x, cardData.y, cardData.layer, cardData.emoji);
                        card.visible = cardData.visible;
                        card.selected = cardData.selected;
                        card.isClickable = cardData.isClickable;
                        card.isBlocked = cardData.isBlocked;
                        this.slots.push(card);
                    });
                    
                    // æ›´æ–°æ§½ä½æ˜¾ç¤º
                    this.updateSlotDisplay();
                    
                    // æ¢å¤æ¸¸æˆçŠ¶æ€æ˜¾ç¤º
                    document.getElementById('gameStatus').textContent = gameData.gameStatus;
                    
                    // é‡ç»˜æ¸¸æˆ
                    this.draw();
                    this.updateEmojiCountDisplay();
                    
                    return true;
                } catch (error) {
                    console.error('åŠ è½½æ¸¸æˆè¿›åº¦å¤±è´¥:', error);
                    return false;
                }
            }

            // è‡ªåŠ¨ä¿å­˜æ¸¸æˆè¿›åº¦
            autoSave() {
                const gameData = {
                    currentLevel: this.currentLevel,
                    cards: this.cards.map(card => ({
                        x: card.x,
                        y: card.y,
                        width: card.width,
                        height: card.height,
                        layer: card.layer,
                        emoji: card.emoji,
                        visible: card.visible,
                        selected: card.selected,
                        isClickable: card.isClickable,
                        isBlocked: card.isBlocked
                    })),
                    slots: this.slots.map(card => ({
                        x: card.x,
                        y: card.y,
                        width: card.width,
                        height: card.height,
                        layer: card.layer,
                        emoji: card.emoji,
                        visible: card.visible,
                        selected: card.selected,
                        isClickable: card.isClickable,
                        isBlocked: card.isBlocked
                    })),
                    gameStatus: document.getElementById('gameStatus').textContent
                };
                
                localStorage.setItem('ylgy_gameSave', JSON.stringify(gameData));
            }

            // ç”Ÿæˆç¡®ä¿å¯æ¶ˆé™¤çš„å¡ç‰Œæ•°ç»„ï¼ˆæœ€ç®€å•çš„ç‰ˆæœ¬ï¼‰
            generateSolvableCards(totalCards, availableEmojis, levelConfig) {
                // ä½¿ç”¨æœ€ç®€å•ã€æœ€å¯é çš„æ–¹æ³•
                const adjustedTotalCards = Math.floor(totalCards / 3) * 3;
                const totalGroups = adjustedTotalCards / 3;
                
                // åªä½¿ç”¨å‰6ç§emojiï¼Œç¡®ä¿ç»å¯¹å®‰å…¨
                const safeEmojis = availableEmojis.slice(0, Math.min(6, availableEmojis.length));
                
                const cardEmojis = [];
                
                // å¹³å‡åˆ†é…ç»„æ•°åˆ°æ¯ç§emoji
                const groupsPerEmoji = Math.floor(totalGroups / safeEmojis.length);
                const remainingGroups = totalGroups % safeEmojis.length;
                
                console.log(`ç”Ÿæˆ${totalGroups}ç»„å¡ç‰Œï¼Œä½¿ç”¨${safeEmojis.length}ç§emoji`);
                console.log(`æ¯ç§emojiåŸºç¡€ç»„æ•°: ${groupsPerEmoji}`);
                console.log(`å‰©ä½™ç»„æ•°: ${remainingGroups}`);
                
                // ä¸ºæ¯ç§emojiåˆ†é…å®Œæ•´çš„ç»„æ•°
                safeEmojis.forEach((emoji, index) => {
                    const groupsForThisEmoji = groupsPerEmoji + (index < remainingGroups ? 1 : 0);
                    console.log(`${emoji}: ${groupsForThisEmoji}ç»„ (${groupsForThisEmoji * 3}å¼ )`);
                    
                    for (let i = 0; i < groupsForThisEmoji; i++) {
                        // æ¯ç»„3å¼ ç›¸åŒçš„emoji
                        for (let j = 0; j < 3; j++) {
                            cardEmojis.push(emoji);
                        }
                    }
                });
                
                // æ ¹æ®å…³å¡æ‰“ä¹±ç¨‹åº¦è¿›è¡Œæ‰“ä¹±
                const shuffleIterations = Math.floor(cardEmojis.length * levelConfig.shuffleRate);
                console.log(`æ‰“ä¹±æ¬¡æ•°: ${shuffleIterations}`);
                
                for (let iter = 0; iter < shuffleIterations; iter++) {
                    for (let i = cardEmojis.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [cardEmojis[i], cardEmojis[j]] = [cardEmojis[j], cardEmojis[i]];
                    }
                }
                
                // éªŒè¯ï¼šç¡®ä¿æ‰€æœ‰emojiæ•°é‡éƒ½æ˜¯3çš„å€æ•°
                const validationCounts = {};
                cardEmojis.forEach(emoji => {
                    validationCounts[emoji] = (validationCounts[emoji] || 0) + 1;
                });
                
                console.log('ç”Ÿæˆåçš„emojiæ•°é‡:', validationCounts);
                
                let isValid = true;
                Object.values(validationCounts).forEach(count => {
                    if (count % 3 !== 0) {
                        isValid = false;
                        console.error(`ä¸¥é‡é”™è¯¯: Emojiæ•°é‡${count}ä¸æ˜¯3çš„å€æ•°`);
                    }
                });
                
                if (!isValid || cardEmojis.length !== adjustedTotalCards) {
                    console.error('ç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨ç´§æ€¥å¤‡ç”¨æ–¹æ¡ˆ');
                    return this.generateEmergencyCards(adjustedTotalCards, safeEmojis);
                }
                
                console.log('âœ… æˆåŠŸç”Ÿæˆæœ‰æ•ˆçš„å¡ç‰Œæ•°ç»„');
                return cardEmojis;
            }

            // ç”Ÿæˆç»å¯¹å®‰å…¨çš„å¡ç‰Œæ•°ç»„ï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰
            generateSafeCards(totalCards, availableEmojis) {
                const cardEmojis = [];
                const groupsNeeded = Math.floor(totalCards / 3);
                
                // ä½¿ç”¨å¾ªç¯åˆ†é…ï¼Œç¡®ä¿æ¯ç§emojiéƒ½æœ‰å®Œæ•´çš„3å€æ•°ç»„
                for (let i = 0; i < groupsNeeded; i++) {
                    const emoji = availableEmojis[i % availableEmojis.length];
                    for (let j = 0; j < 3; j++) {
                        cardEmojis.push(emoji);
                    }
                }
                
                // æ‰“ä¹±æ•°ç»„
                for (let i = cardEmojis.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [cardEmojis[i], cardEmojis[j]] = [cardEmojis[j], cardEmojis[i]];
                }
                
                return cardEmojis;
            }

            // ç´§æ€¥å¤‡ç”¨æ–¹æ¡ˆï¼šæœ€ç®€å•çš„ç”Ÿæˆæ–¹æ³•
            generateEmergencyCards(totalCards, availableEmojis) {
                const cardEmojis = [];
                const groupsNeeded = Math.floor(totalCards / 3);
                
                // åªä½¿ç”¨å‰6ç§emojiï¼Œç¡®ä¿ç»å¯¹å®‰å…¨
                const safeEmojis = availableEmojis.slice(0, Math.min(6, availableEmojis.length));
                
                console.log(`ä½¿ç”¨ç´§æ€¥å¤‡ç”¨æ–¹æ¡ˆï¼Œç”Ÿæˆ${groupsNeeded}ç»„å¡ç‰Œ`);
                console.log('ä½¿ç”¨çš„emoji:', safeEmojis);
                
                // å¹³å‡åˆ†é…ç»„æ•°åˆ°æ¯ç§emoji
                const groupsPerEmoji = Math.floor(groupsNeeded / safeEmojis.length);
                const remainingGroups = groupsNeeded % safeEmojis.length;
                
                console.log(`æ¯ç§emojiåŸºç¡€ç»„æ•°: ${groupsPerEmoji}`);
                console.log(`å‰©ä½™ç»„æ•°: ${remainingGroups}`);
                
                // ä¸ºæ¯ç§emojiåˆ†é…å®Œæ•´çš„ç»„æ•°
                safeEmojis.forEach((emoji, index) => {
                    const groupsForThisEmoji = groupsPerEmoji + (index < remainingGroups ? 1 : 0);
                    console.log(`${emoji}: ${groupsForThisEmoji}ç»„ (${groupsForThisEmoji * 3}å¼ )`);
                    
                    for (let i = 0; i < groupsForThisEmoji; i++) {
                        // æ¯ç»„3å¼ ç›¸åŒçš„emoji
                        for (let j = 0; j < 3; j++) {
                            cardEmojis.push(emoji);
                        }
                    }
                });
                
                // éªŒè¯ç”Ÿæˆçš„æ•°ç»„
                const validationCounts = {};
                cardEmojis.forEach(emoji => {
                    validationCounts[emoji] = (validationCounts[emoji] || 0) + 1;
                });
                
                console.log('ç´§æ€¥å¤‡ç”¨æ–¹æ¡ˆç”Ÿæˆçš„emojiæ•°é‡:', validationCounts);
                
                let isValid = true;
                Object.values(validationCounts).forEach(count => {
                    if (count % 3 !== 0) {
                        isValid = false;
                        console.error(`ç´§æ€¥å¤‡ç”¨æ–¹æ¡ˆå¤±è´¥: Emojiæ•°é‡${count}ä¸æ˜¯3çš„å€æ•°`);
                    }
                });
                
                if (isValid) {
                    console.log('âœ… ç´§æ€¥å¤‡ç”¨æ–¹æ¡ˆæˆåŠŸç”Ÿæˆæœ‰æ•ˆå¡ç‰Œæ•°ç»„');
                } else {
                    console.error('âŒ ç´§æ€¥å¤‡ç”¨æ–¹æ¡ˆä¹Ÿå¤±è´¥äº†ï¼');
                }
                
                return cardEmojis;
            }

            // åŠ¨æ€ä¿®å¤emojiæ•°é‡ï¼Œç¡®ä¿æ‰€æœ‰éƒ½æ˜¯3çš„å€æ•°
            fixEmojiCounts(cardEmojis, availableEmojis) {
                console.log('=== å¼€å§‹åŠ¨æ€ä¿®å¤emojiæ•°é‡ ===');
                
                // ç»Ÿè®¡å½“å‰æ¯ç§emojiçš„æ•°é‡
                const emojiCounts = {};
                cardEmojis.forEach(emoji => {
                    emojiCounts[emoji] = (emojiCounts[emoji] || 0) + 1;
                });
                
                console.log('ä¿®å¤å‰çš„emojiæ•°é‡:', emojiCounts);
                
                // è®¡ç®—éœ€è¦è¡¥å……çš„å¡ç‰Œ
                const cardsToAdd = [];
                let totalAdded = 0;
                
                Object.entries(emojiCounts).forEach(([emoji, count]) => {
                    const remainder = count % 3;
                    if (remainder !== 0) {
                        const needed = (3 - remainder) % 3; // éœ€è¦è¡¥å……çš„æ•°é‡
                        console.log(`${emoji}: å½“å‰${count}å¼ ï¼Œä½™æ•°${remainder}ï¼Œéœ€è¦è¡¥å……${needed}å¼ `);
                        
                        for (let i = 0; i < needed; i++) {
                            cardsToAdd.push(emoji);
                        }
                        totalAdded += needed;
                    }
                });
                
                if (totalAdded === 0) {
                    console.log('âœ… æ‰€æœ‰emojiæ•°é‡éƒ½æ˜¯3çš„å€æ•°ï¼Œæ— éœ€ä¿®å¤');
                    return cardEmojis;
                }
                
                console.log(`æ€»å…±éœ€è¦è¡¥å……${totalAdded}å¼ å¡ç‰Œ`);
                
                // å°†è¡¥å……çš„å¡ç‰Œæ·»åŠ åˆ°æ•°ç»„ä¸­
                const fixedCardEmojis = [...cardEmojis, ...cardsToAdd];
                
                // éªŒè¯ä¿®å¤ç»“æœ
                const fixedCounts = {};
                fixedCardEmojis.forEach(emoji => {
                    fixedCounts[emoji] = (fixedCounts[emoji] || 0) + 1;
                });
                
                console.log('ä¿®å¤åçš„emojiæ•°é‡:', fixedCounts);
                
                // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨ä¿®å¤æˆåŠŸ
                let allValid = true;
                Object.entries(fixedCounts).forEach(([emoji, count]) => {
                    if (count % 3 !== 0) {
                        allValid = false;
                        console.error(`âŒ ä¿®å¤å¤±è´¥: ${emoji}ä»æœ‰${count}å¼ ï¼Œä¸æ˜¯3çš„å€æ•°`);
                    } else {
                        console.log(`âœ… ä¿®å¤æˆåŠŸ: ${emoji}ç°åœ¨æœ‰${count}å¼ `);
                    }
                });
                
                if (allValid) {
                    console.log(`âœ… åŠ¨æ€ä¿®å¤å®Œæˆï¼æ€»å…±è¡¥å……äº†${totalAdded}å¼ å¡ç‰Œ`);
                } else {
                    console.error('âŒ åŠ¨æ€ä¿®å¤å¤±è´¥ï¼');
                }
                
                return fixedCardEmojis;
            }

            // è°ƒè¯•æ£€æµ‹æ¸¸æˆçŠ¶æ€
            debugGameState() {
                console.log('=== æ¸¸æˆçŠ¶æ€è°ƒè¯•æ£€æµ‹ ===');
                console.log(`å½“å‰å…³å¡: ${this.currentLevel}`);
                console.log(`æ€»å¡ç‰Œæ•°: ${this.cards.length}`);
                console.log(`æ§½ä½å¡ç‰Œæ•°: ${this.slots.length}`);
                
                // è·å–æ‰€æœ‰å¡ç‰Œï¼ˆåŒ…æ‹¬æ‰€æœ‰ç”Ÿæˆçš„å¡ç‰Œå’Œåœ¨æ§½ä½ä¸­çš„ï¼‰
                const allCards = [...this.cards, ...this.slots];
                console.log(`å‰©ä½™å¡ç‰Œæ€»æ•°: ${allCards.length}`);
                
                // ç»Ÿè®¡æ¯ç§emojiçš„æ•°é‡
                const emojiCounts = {};
                allCards.forEach(card => {
                    emojiCounts[card.emoji] = (emojiCounts[card.emoji] || 0) + 1;
                });
                
                console.log('=== Emojiæ•°é‡ç»Ÿè®¡ ===');
                Object.keys(emojiCounts).forEach(emoji => {
                    const count = emojiCounts[emoji];
                    const remainder = count % 3;
                    console.log(`${emoji}: ${count}å¼  (ä½™æ•°: ${remainder})`);
                });
                
                // æ£€æµ‹æ˜¯å¦æ‰€æœ‰emojiéƒ½èƒ½3-3é…å¯¹ç©·å°½
                const canComplete = this.checkGameCompletable(emojiCounts);
                console.log('=== é…å¯¹æ£€æµ‹ç»“æœ ===');
                console.log(`æ¸¸æˆæ˜¯å¦å¯å®Œæˆ: ${canComplete ? 'æ˜¯' : 'å¦'}`);
                
                if (!canComplete) {
                    console.log('âš ï¸  è­¦å‘Šï¼šæ¸¸æˆæ— æ³•å®Œæˆï¼å­˜åœ¨æ— æ³•é…å¯¹çš„emojiï¼');
                    this.analyzeProblematicEmojis(emojiCounts);
                } else {
                    console.log('âœ… æ¸¸æˆå¯ä»¥æ­£å¸¸å®Œæˆï¼Œæ‰€æœ‰emojiéƒ½å¯ä»¥3-3é…å¯¹ç©·å°½');
                }
                
                // è¯¦ç»†åˆ†æé…å¯¹å¯èƒ½æ€§
                this.analyzePairingPossibilities(emojiCounts);
                
                // æ˜¾ç¤ºæ§½ä½ä¸­çš„å¡ç‰Œ
                console.log('=== æ§½ä½çŠ¶æ€ ===');
                this.slots.forEach((card, index) => {
                    console.log(`æ§½ä½${index + 1}: ${card.emoji}`);
                });
                
                // æ˜¾ç¤ºå¯ç‚¹å‡»çš„å¡ç‰Œæ•°é‡
                const clickableCards = this.cards.filter(card => card.visible && card.isClickable);
                console.log(`å¯ç‚¹å‡»å¡ç‰Œæ•°: ${clickableCards.length}`);
                
                console.log('=== æ£€æµ‹å®Œæˆ ===');
            }

            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦å¯å®Œæˆ
            checkGameCompletable(emojiCounts) {
                // æ£€æŸ¥æ¯ç§emojiçš„æ•°é‡æ˜¯å¦éƒ½æ˜¯3çš„å€æ•°
                for (const emoji in emojiCounts) {
                    const count = emojiCounts[emoji];
                    if (count % 3 !== 0) {
                        return false;
                    }
                }
                return true;
            }

            // åˆ†ææœ‰é—®é¢˜çš„emoji
            analyzeProblematicEmojis(emojiCounts) {
                console.log('=== é—®é¢˜Emojiåˆ†æ ===');
                Object.keys(emojiCounts).forEach(emoji => {
                    const count = emojiCounts[emoji];
                    const remainder = count % 3;
                    if (remainder !== 0) {
                        console.log(`é—®é¢˜emoji ${emoji}: ${count}å¼ , ä½™æ•°${remainder}`);
                        if (remainder === 1) {
                            console.log(`  -> éœ€è¦${3 - remainder}å¼ æ‰èƒ½é…å¯¹ï¼Œä½†åªæœ‰1å¼ ï¼Œæ— æ³•é…å¯¹`);
                        } else if (remainder === 2) {
                            console.log(`  -> éœ€è¦${3 - remainder}å¼ æ‰èƒ½é…å¯¹ï¼Œä½†åªæœ‰2å¼ ï¼Œæ— æ³•é…å¯¹`);
                        }
                    }
                });
            }

            // åˆ†æé…å¯¹å¯èƒ½æ€§
            analyzePairingPossibilities(emojiCounts) {
                console.log('=== é…å¯¹å¯èƒ½æ€§åˆ†æ ===');
                let totalPairs = 0;
                let remainingCards = 0;
                
                Object.keys(emojiCounts).forEach(emoji => {
                    const count = emojiCounts[emoji];
                    const pairs = Math.floor(count / 3);
                    const remainder = count % 3;
                    
                    console.log(`${emoji}: å¯ç»„æˆ${pairs}ç»„3å¼ é…å¯¹ï¼Œå‰©ä½™${remainder}å¼ `);
                    totalPairs += pairs;
                    remainingCards += remainder;
                });
                
                console.log(`æ€»è®¡å¯ç»„æˆ${totalPairs}ç»„3å¼ é…å¯¹`);
                console.log(`æ€»è®¡å‰©ä½™${remainingCards}å¼ æ— æ³•é…å¯¹`);
                
                if (remainingCards === 0) {
                    console.log('âœ… æ‰€æœ‰å¡ç‰Œéƒ½å¯ä»¥å®Œç¾é…å¯¹');
                } else {
                    console.log(`âŒ æœ‰${remainingCards}å¼ å¡ç‰Œæ— æ³•é…å¯¹`);
                }
            }

            // æ›´æ–°å…³å¡æ˜¾ç¤º
            updateLevelDisplay() {
                const levelConfig = this.levelConfigs[this.currentLevel - 1];
                document.getElementById('currentLevel').textContent = this.currentLevel;
                document.getElementById('difficulty').textContent = levelConfig.name;
            }

            // æ›´æ–°emojiæ•°é‡æ˜¾ç¤º
            updateEmojiCountDisplay() {
                const emojiCount = document.getElementById('emojiCount');
                const allCards = [...this.cards.filter(card => card.visible), ...this.slots];
                
                const counts = {};
                allCards.forEach(card => {
                    counts[card.emoji] = (counts[card.emoji] || 0) + 1;
                });
                
                let html = '';
                Object.keys(counts).forEach(emoji => {
                    const count = counts[emoji];
                    const remainder = count % 3;
                    let className = 'emoji-count-item';
                    
                    if (remainder === 1) {
                        className += ' danger';
                    } else if (remainder === 2) {
                        className += ' warning';
                    }
                    
                    html += `<span class="${className}">${emoji}: ${count}</span>`;
                });
                
                emojiCount.innerHTML = html;
            }

            // ä¸‹ä¸€å…³
            nextLevel() {
                if (this.currentLevel >= this.maxLevel) {
                    document.getElementById('gameStatus').textContent = 'æ­å–œä½ ï¼å·²ç»é€šå…³æ‰€æœ‰å…³å¡ï¼';
                    return;
                }

                this.currentLevel++;
                document.getElementById('nextLevelBtn').style.display = 'none';
                
                // æ¸…ç©ºæ¸¸æˆçŠ¶æ€
                this.cards = [];
                this.slots = [];
                
                // æ¸…ç©ºæ§½ä½æ˜¾ç¤º
                this.initSlots();
                
                // é‡æ–°åˆå§‹åŒ–æ¸¸æˆ
                this.init();
                
                document.getElementById('gameStatus').textContent = `ç¬¬${this.currentLevel}å…³å¼€å§‹ï¼`;
                this.updateEmojiCountDisplay();
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        window.addEventListener('load', () => {
            const canvas = document.getElementById('gameCanvas');
            window.game = new Game(canvas);
            
            // å°è¯•åŠ è½½ä¿å­˜çš„æ¸¸æˆè¿›åº¦
            if (!window.game.loadGame()) {
                // å¦‚æœæ²¡æœ‰ä¿å­˜çš„è¿›åº¦ï¼Œæ˜¾ç¤ºæ–°æ¸¸æˆæç¤º
                document.getElementById('gameStatus').textContent = 'ç‚¹å‡»å¡ç‰Œå¼€å§‹æ¸¸æˆ';
            }
        });
    </script>
</body>
</html>